{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { cloneElement } from 'react';\nimport { isBoolean, isString, isNumber, isUndefined } from '../services/predicate';\nimport { isElement } from 'react-is';\nfunction isPrimitive(value) {\n  return isBoolean(value) || isString(value) || isNumber(value) || isUndefined(value);\n}\nfunction hasPropName(child) {\n  return child ? typeof child === 'object' && child.hasOwnProperty('propName') : false;\n}\n\n/**\n * Replaces placeholder values in `input` with their matching value in `values`\n * e.g. input:'Hello, {name}' will replace `{name}` with `values[name]`\n * @param {string} input\n * @param {RenderableValues} values\n * @param {Function} i18nMappingFunc\n * @returns {string | React.ReactChild[]}\n */\nexport function processStringToChildren(input, values, i18nMappingFunc) {\n  const children = [];\n  let child;\n  function appendCharToChild(char) {\n    if (child === undefined) {\n      // starting a new string literal\n      child = char;\n    } else if (typeof child === 'string') {\n      // existing string literal\n      child = child + char;\n    } else if (hasPropName(child)) {\n      // adding to the propName of a values lookup\n      child.propName = child.propName + char;\n    }\n  }\n  function appendValueToChildren(value) {\n    if (value === undefined) {\n      return;\n    } else if (isElement(value)) {\n      // an array with any ReactElements will be kept as an array\n      // so they need to be assigned a key\n      children.push( /*#__PURE__*/cloneElement(value, {\n        key: children.length\n      }));\n    } else if (hasPropName(value)) {\n      // this won't be called, propName children are converted to a ReactChild before calling this\n    } else {\n      // everything else can go straight in\n      if (i18nMappingFunc !== undefined && typeof value === 'string') {\n        value = i18nMappingFunc(value);\n      }\n      children.push(value);\n    }\n  }\n\n  // if we don't encounter a non-primitive\n  // then `children` can be concatenated together at the end\n  let encounteredNonPrimitive = false;\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    if (char === '\\\\') {\n      // peek at the next character to know if this is an escape\n      const nextChar = input[i + 1];\n      let charToAdd = char; // if this isn't an escape sequence then we will add the backslash\n\n      if (nextChar === '{' || nextChar === '}') {\n        // escaping a brace\n        i += 1; // advance passed the brace\n        charToAdd = input[i];\n      }\n      appendCharToChild(charToAdd);\n    } else if (char === '{') {\n      appendValueToChildren(child);\n      child = {\n        propName: ''\n      };\n    } else if (char === '}') {\n      const propName = child.propName;\n      if (!values.hasOwnProperty(propName)) {\n        throw new Error(`Key \"${propName}\" not found in ${JSON.stringify(values, null, 2)}`);\n      }\n      const propValue = values[propName];\n      encounteredNonPrimitive = encounteredNonPrimitive || !isPrimitive(propValue);\n      appendValueToChildren(propValue);\n      child = undefined;\n    } else {\n      appendCharToChild(char);\n    }\n  }\n\n  // include any remaining child value\n  appendValueToChildren(child);\n  return encounteredNonPrimitive ? children : children.join('');\n}","map":{"version":3,"names":["cloneElement","isBoolean","isString","isNumber","isUndefined","isElement","isPrimitive","value","hasPropName","child","hasOwnProperty","processStringToChildren","input","values","i18nMappingFunc","children","appendCharToChild","char","undefined","propName","appendValueToChildren","push","key","length","encounteredNonPrimitive","i","nextChar","charToAdd","Error","JSON","stringify","propValue","join"],"sources":["/Users/nikita/Downloads/super_date_picker/src/i18n/i18n_util.tsx"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { cloneElement, ReactChild } from 'react';\nimport {\n  isBoolean,\n  isString,\n  isNumber,\n  isUndefined,\n} from '../services/predicate';\nimport { isElement } from 'react-is';\nimport { RenderableValues } from '../context/context';\n\nfunction isPrimitive(value: ReactChild | undefined) {\n  return (\n    isBoolean(value) || isString(value) || isNumber(value) || isUndefined(value)\n  );\n}\n\ntype Child = string | { propName: string } | ReactChild | undefined;\n\nfunction hasPropName(child: Child): child is { propName: string } {\n  return child\n    ? typeof child === 'object' && child.hasOwnProperty('propName')\n    : false;\n}\n\n/**\n * Replaces placeholder values in `input` with their matching value in `values`\n * e.g. input:'Hello, {name}' will replace `{name}` with `values[name]`\n * @param {string} input\n * @param {RenderableValues} values\n * @param {Function} i18nMappingFunc\n * @returns {string | React.ReactChild[]}\n */\nexport function processStringToChildren(\n  input: string,\n  values: RenderableValues,\n  i18nMappingFunc?: (token: string) => string\n): string | ReactChild[] {\n  const children: ReactChild[] = [];\n\n  let child: Child;\n\n  function appendCharToChild(char: string) {\n    if (child === undefined) {\n      // starting a new string literal\n      child = char;\n    } else if (typeof child === 'string') {\n      // existing string literal\n      child = child + char;\n    } else if (hasPropName(child)) {\n      // adding to the propName of a values lookup\n      child.propName = child.propName + char;\n    }\n  }\n\n  function appendValueToChildren(value: Child) {\n    if (value === undefined) {\n      return;\n    } else if (isElement(value)) {\n      // an array with any ReactElements will be kept as an array\n      // so they need to be assigned a key\n      children.push(cloneElement(value, { key: children.length }));\n    } else if (hasPropName(value)) {\n      // this won't be called, propName children are converted to a ReactChild before calling this\n    } else {\n      // everything else can go straight in\n      if (i18nMappingFunc !== undefined && typeof value === 'string') {\n        value = i18nMappingFunc(value);\n      }\n      children.push(value);\n    }\n  }\n\n  // if we don't encounter a non-primitive\n  // then `children` can be concatenated together at the end\n  let encounteredNonPrimitive = false;\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n\n    if (char === '\\\\') {\n      // peek at the next character to know if this is an escape\n      const nextChar = input[i + 1];\n      let charToAdd = char; // if this isn't an escape sequence then we will add the backslash\n\n      if (nextChar === '{' || nextChar === '}') {\n        // escaping a brace\n        i += 1; // advance passed the brace\n        charToAdd = input[i];\n      }\n      appendCharToChild(charToAdd);\n    } else if (char === '{') {\n      appendValueToChildren(child);\n      child = { propName: '' };\n    } else if (char === '}') {\n      const propName = (child as { propName: string }).propName;\n      if (!values.hasOwnProperty(propName)) {\n        throw new Error(\n          `Key \"${propName}\" not found in ${JSON.stringify(values, null, 2)}`\n        );\n      }\n      const propValue = values[propName];\n      encounteredNonPrimitive =\n        encounteredNonPrimitive || !isPrimitive(propValue);\n      appendValueToChildren(propValue);\n      child = undefined;\n    } else {\n      appendCharToChild(char);\n    }\n  }\n\n  // include any remaining child value\n  appendValueToChildren(child);\n\n  return encounteredNonPrimitive ? children : children.join('');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}