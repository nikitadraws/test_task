{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { isNil, isFunction, isString } from '../predicate';\nimport moment from 'moment';\nconst calendar = function (value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const refTime = options.refTime;\n  return moment(value).calendar(refTime, options);\n};\nexport const dateFormatAliases = {\n  date: 'D MMM YYYY',\n  longDate: 'DD MMMM YYYY',\n  shortDate: 'D MMM YY',\n  dateTime: 'D MMM YYYY HH:mm',\n  longDateTime: 'DD MMMM YYYY HH:mm:ss',\n  shortDateTime: 'D MMM YY HH:mm',\n  dobShort: 'Do MMM YY',\n  dobLong: 'Do MMMM YYYY',\n  iso8601: 'YYYY-MM-DDTHH:mm:ss.SSSZ',\n  calendar,\n  calendarDateTime: (value, options) => {\n    return calendar(value, {\n      sameDay: '[Today at] H:mmA',\n      nextDay: '[Tomorrow at] H:mmA',\n      nextWeek: 'dddd [at] H:mmA',\n      lastDay: '[Yesterday at] H:mmA',\n      lastWeek: '[Last] dddd [at] H:mmA',\n      sameElse: 'Do MMM YYYY [at] H:mmA',\n      ...options\n    });\n  },\n  calendarDate: (value, options) => {\n    return calendar(value, {\n      sameDay: '[Today]',\n      nextDay: '[Tomorrow]',\n      nextWeek: 'dddd',\n      lastDay: '[Yesterday]',\n      lastWeek: '[Last] dddd',\n      sameElse: 'Do MMM YYYY',\n      ...options\n    });\n  }\n};\nfunction isStringADateFormat(x) {\n  return dateFormatAliases.hasOwnProperty(x);\n}\nfunction instanceOfFormatDateConfig(x) {\n  return typeof x === 'object' && (x.hasOwnProperty('format') || x.hasOwnProperty('nil') || x.hasOwnProperty('options'));\n}\nexport const formatDate = function (value) {\n  let dateFormatKeyOrConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'dateTime';\n  if (isString(dateFormatKeyOrConfig)) {\n    if (isNil(value)) {\n      return '';\n    }\n    const dateFormatStrOrFunc = isStringADateFormat(dateFormatKeyOrConfig) ? dateFormatAliases[dateFormatKeyOrConfig] : dateFormatKeyOrConfig;\n    if (isFunction(dateFormatStrOrFunc)) {\n      return dateFormatStrOrFunc(value, {});\n    }\n    if (isString(dateFormatStrOrFunc)) {\n      return moment(value).format(dateFormatStrOrFunc);\n    }\n  }\n  if (instanceOfFormatDateConfig(dateFormatKeyOrConfig)) {\n    const {\n      format = 'dateTime',\n      nil = '',\n      options\n    } = dateFormatKeyOrConfig;\n    const dateFormat = dateFormatAliases[format] || format;\n    if (isNil(value)) {\n      return nil;\n    }\n    if (isFunction(dateFormat)) {\n      return dateFormat(value, options);\n    }\n    if (isString(dateFormat)) {\n      return moment(value).format(dateFormat);\n    }\n  }\n  throw new Error(`Failed to format value using dateFormatKeyOrConfig: ${dateFormatKeyOrConfig}`);\n};","map":{"version":3,"names":["isNil","isFunction","isString","moment","calendar","value","options","refTime","dateFormatAliases","date","longDate","shortDate","dateTime","longDateTime","shortDateTime","dobShort","dobLong","iso8601","calendarDateTime","sameDay","nextDay","nextWeek","lastDay","lastWeek","sameElse","calendarDate","isStringADateFormat","x","hasOwnProperty","instanceOfFormatDateConfig","formatDate","dateFormatKeyOrConfig","dateFormatStrOrFunc","format","nil","dateFormat","Error"],"sources":["/Users/nikita/Downloads/super_date_picker/src/services/format/format_date.ts"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { isNil, isFunction, isString } from '../predicate';\nimport moment from 'moment';\n\ntype CalendarOptions = moment.CalendarSpec & {\n  refTime?: moment.MomentInput;\n};\n\nconst calendar = (value: moment.MomentInput, options: CalendarOptions = {}) => {\n  const refTime = options.refTime;\n  return moment(value).calendar(refTime, options);\n};\n\nexport const dateFormatAliases = {\n  date: 'D MMM YYYY',\n  longDate: 'DD MMMM YYYY',\n  shortDate: 'D MMM YY',\n  dateTime: 'D MMM YYYY HH:mm',\n  longDateTime: 'DD MMMM YYYY HH:mm:ss',\n  shortDateTime: 'D MMM YY HH:mm',\n  dobShort: 'Do MMM YY',\n  dobLong: 'Do MMMM YYYY',\n  iso8601: 'YYYY-MM-DDTHH:mm:ss.SSSZ',\n  calendar,\n  calendarDateTime: (\n    value: moment.MomentInput,\n    options: moment.CalendarSpec\n  ) => {\n    return calendar(value, {\n      sameDay: '[Today at] H:mmA',\n      nextDay: '[Tomorrow at] H:mmA',\n      nextWeek: 'dddd [at] H:mmA',\n      lastDay: '[Yesterday at] H:mmA',\n      lastWeek: '[Last] dddd [at] H:mmA',\n      sameElse: 'Do MMM YYYY [at] H:mmA',\n      ...options,\n    });\n  },\n  calendarDate: (value: moment.MomentInput, options: moment.CalendarSpec) => {\n    return calendar(value, {\n      sameDay: '[Today]',\n      nextDay: '[Tomorrow]',\n      nextWeek: 'dddd',\n      lastDay: '[Yesterday]',\n      lastWeek: '[Last] dddd',\n      sameElse: 'Do MMM YYYY',\n      ...options,\n    });\n  },\n};\n\ntype DateFormat = keyof typeof dateFormatAliases;\n\ninterface FormatDateConfig {\n  format: DateFormat;\n  nil: string;\n  options: any;\n}\n\nfunction isStringADateFormat(x: string): x is DateFormat {\n  return dateFormatAliases.hasOwnProperty(x);\n}\n\nfunction instanceOfFormatDateConfig(x: any): x is Partial<FormatDateConfig> {\n  return (\n    typeof x === 'object' &&\n    (x.hasOwnProperty('format') ||\n      x.hasOwnProperty('nil') ||\n      x.hasOwnProperty('options'))\n  );\n}\n\nexport const formatDate: (\n  value?: moment.MomentInput,\n  dateFormatKeyOrConfig?: DateFormat | string | Partial<FormatDateConfig>\n) => string = (value, dateFormatKeyOrConfig = 'dateTime') => {\n  if (isString(dateFormatKeyOrConfig)) {\n    if (isNil(value)) {\n      return '';\n    }\n\n    const dateFormatStrOrFunc = isStringADateFormat(dateFormatKeyOrConfig)\n      ? dateFormatAliases[dateFormatKeyOrConfig]\n      : dateFormatKeyOrConfig;\n\n    if (isFunction(dateFormatStrOrFunc)) {\n      return dateFormatStrOrFunc(value, {});\n    }\n\n    if (isString(dateFormatStrOrFunc)) {\n      return moment(value).format(dateFormatStrOrFunc);\n    }\n  }\n\n  if (instanceOfFormatDateConfig(dateFormatKeyOrConfig)) {\n    const { format = 'dateTime', nil = '', options } = dateFormatKeyOrConfig;\n\n    const dateFormat = dateFormatAliases[format] || format;\n\n    if (isNil(value)) {\n      return nil;\n    }\n\n    if (isFunction(dateFormat)) {\n      return dateFormat(value, options);\n    }\n\n    if (isString(dateFormat)) {\n      return moment(value).format(dateFormat);\n    }\n  }\n\n  throw new Error(\n    `Failed to format value using dateFormatKeyOrConfig: ${dateFormatKeyOrConfig}`\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}