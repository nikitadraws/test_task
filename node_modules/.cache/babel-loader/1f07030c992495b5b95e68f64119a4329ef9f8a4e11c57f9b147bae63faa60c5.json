{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nexport const POSITIONS = ['top', 'right', 'bottom', 'left'];\nconst relatedDimension = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width'\n};\nconst dimensionPositionAttribute = {\n  height: 'top',\n  width: 'left'\n};\nconst positionComplements = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right'\n};\n\n// always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\nconst positionSubstitutes = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top'\n};\nconst getBufferValues = buffer => {\n  if (Array.isArray(buffer)) {\n    const [topBuffer, rightBuffer, bottomBuffer, leftBuffer] = buffer;\n    return [topBuffer, rightBuffer, bottomBuffer, leftBuffer];\n  }\n  return [buffer, buffer, buffer, buffer];\n};\n\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placement's relation to the anchor or undefined\n * there's no room.\n */\nexport function findPopoverPosition(_ref) {\n  let {\n    anchor,\n    popover,\n    align,\n    position,\n    forcePosition,\n    buffer = 16,\n    offset = 0,\n    allowCrossAxis = true,\n    container,\n    arrowConfig,\n    returnBoundingBox\n  } = _ref;\n  // find the screen-relative bounding boxes of the anchor, popover, and container\n  const anchorBoundingBox = getElementBoundingBox(anchor);\n  const popoverBoundingBox = getElementBoundingBox(popover);\n\n  // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n  const documentWidth = document.documentElement.clientWidth || window.innerWidth;\n  const documentHeight = document.documentElement.clientHeight || window.innerHeight;\n  const windowBoundingBox = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth\n  };\n\n  // if no container element is given fall back to using the window viewport\n  const containerBoundingBox = container ? getElementBoundingBox(container) : windowBoundingBox;\n\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n\n  // Try the user-desired position first.\n  const iterationPositions = [position];\n  // keep user-defined alignment in the original positions.\n  const iterationAlignments = [align];\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(positionSubstitutes[position],\n      // Switch to the cross axis.\n      positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conflicts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (position === align || align !== undefined && position === positionComplements[align]) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n  let bestFit = undefined;\n  let bestPosition = null;\n  for (let idx = 0; idx < iterationPositions.length; idx++) {\n    const iterationPosition = iterationPositions[idx];\n\n    // See if we can find a position with a better fit than we've found so far.\n    const screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox,\n      popoverBoundingBox,\n      windowBoundingBox,\n      containerBoundingBox,\n      offset,\n      buffer,\n      arrowConfig\n    });\n    if (bestFit === undefined || screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow\n      };\n\n      // If we've already found the ideal fit, use that position.\n      if (bestFit === 1) {\n        break;\n      }\n    }\n\n    // If we haven't improved the fit, then continue on and try a new position.\n  }\n\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n  return bestPosition;\n}\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\nexport function getPopoverScreenCoordinates(_ref2) {\n  let {\n    position,\n    align,\n    anchorBoundingBox,\n    popoverBoundingBox,\n    windowBoundingBox,\n    containerBoundingBox,\n    arrowConfig,\n    offset = 0,\n    buffer = 0\n  } = _ref2;\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n\n  const crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n  const crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n  const crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  const [topBuffer, rightBuffer, bottomBuffer, leftBuffer] = getBufferValues(buffer);\n  const {\n    crossAxisPosition,\n    crossAxisArrowPosition\n  } = getCrossAxisPosition({\n    crossAxisFirstSide,\n    crossAxisSecondSide,\n    crossAxisDimension,\n    position,\n    align,\n    buffer,\n    offset,\n    windowBoundingBox,\n    containerBoundingBox,\n    popoverBoundingBox,\n    anchorBoundingBox,\n    arrowConfig\n  });\n  const primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n  const primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  const {\n    primaryAxisPosition,\n    primaryAxisArrowPosition\n  } = getPrimaryAxisPosition({\n    position,\n    offset,\n    popoverBoundingBox,\n    anchorBoundingBox,\n    arrowConfig\n  });\n  const popoverPlacement = {\n    [crossAxisFirstSide]: crossAxisPosition,\n    [primaryAxisPositionName]: primaryAxisPosition\n  };\n\n  // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n  const combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n\n  // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n  combinedBoundingBox.top += topBuffer;\n  combinedBoundingBox.right -= rightBuffer;\n  combinedBoundingBox.bottom -= bottomBuffer;\n  combinedBoundingBox.left += leftBuffer;\n  const fit = getVisibleFit({\n    top: popoverPlacement.top,\n    right: popoverPlacement.left + popoverBoundingBox.width,\n    bottom: popoverPlacement.top + popoverBoundingBox.height,\n    left: popoverPlacement.left,\n    width: popoverBoundingBox.width,\n    height: popoverBoundingBox.height\n  }, combinedBoundingBox);\n  const arrow = arrowConfig ? {\n    [crossAxisFirstSide]: crossAxisArrowPosition - popoverPlacement[crossAxisFirstSide],\n    [primaryAxisPositionName]: primaryAxisArrowPosition\n  } : undefined;\n  return {\n    fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? {\n      left: arrow.left,\n      top: arrow.top\n    } : undefined\n  };\n}\nfunction getCrossAxisPosition(_ref3) {\n  let {\n    crossAxisFirstSide,\n    crossAxisSecondSide,\n    crossAxisDimension,\n    position,\n    align,\n    buffer,\n    offset,\n    windowBoundingBox,\n    containerBoundingBox,\n    popoverBoundingBox,\n    anchorBoundingBox,\n    arrowConfig\n  } = _ref3;\n  // how much of the popover overflows past either side of the anchor if its centered\n  const popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  const anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  const anchorHalfSize = anchorSizeOnCrossAxis / 2;\n\n  // the popover's original position on the cross-axis is determined by:\n  const crossAxisPositionOriginal = anchorBoundingBox[crossAxisFirstSide] +\n  // where the anchor is located\n  anchorHalfSize -\n  // plus half anchor dimension\n  popoverSizeOnCrossAxis / 2; // less half the popover dimension\n\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n  const combinedBoundingBox = intersectBoundingBoxes(windowBoundingBox, containerBoundingBox);\n  const availableSpace = getAvailableSpace(anchorBoundingBox, combinedBoundingBox, buffer, offset, position);\n  const minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n  const contentOverflowSize = (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n  let alignAmount = 0;\n  let alignDirection = 1;\n  let amountOfShiftNeeded = 0;\n  let shiftDirection = 1;\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n    const alignedOverflowAmount = contentOverflowSize + alignAmount;\n    const needsShift = alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift ? alignedOverflowAmount - availableSpace[positionComplements[align]] : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    const spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    const spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n    const isShiftTowardFirstSide = spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1;\n\n    // determine which direction has more room and the popover should shift to\n    const leastAvailableSpace = Math.min(spaceAvailableOnFirstSide, spaceAvailableOnSecondSide);\n    const needsShift = contentOverflowSize > leastAvailableSpace;\n    amountOfShiftNeeded = needsShift ? contentOverflowSize - leastAvailableSpace : 0;\n  }\n\n  // shift over the popover if necessary\n  const shiftAmount = amountOfShiftNeeded * shiftDirection;\n  let crossAxisPosition = crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection;\n\n  // if an `arrowConfig` is specified, find where to position the arrow\n  let crossAxisArrowPosition;\n  if (arrowConfig) {\n    const {\n      arrowWidth\n    } = arrowConfig;\n    crossAxisArrowPosition = anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - arrowWidth / 2;\n\n    // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      const difference = crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (crossAxisArrowPosition + minimumSpace + arrowWidth > crossAxisPosition + popoverSizeOnCrossAxis) {\n      // arrow is too close to the maximum side\n      const edge = crossAxisPosition + popoverSizeOnCrossAxis;\n      const difference = crossAxisArrowPosition - (edge - minimumSpace - arrowWidth);\n      crossAxisPosition += difference;\n    }\n  }\n  return {\n    crossAxisPosition,\n    crossAxisArrowPosition\n  };\n}\nfunction getPrimaryAxisPosition(_ref4) {\n  let {\n    position,\n    offset,\n    popoverBoundingBox,\n    anchorBoundingBox,\n    arrowConfig\n  } = _ref4;\n  // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n  const isOffsetDecreasing = position === 'top' || position === 'left';\n  const primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n  const popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension];\n\n  // start at the top or left edge of the anchor element\n  const primaryAxisPositionName = dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n  const anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName];\n\n  // find the popover position on the primary axis\n  const anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  const primaryAxisOffset = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : anchorSizeOnPrimaryAxis;\n  const contentOffset = (offset + primaryAxisOffset) * (isOffsetDecreasing ? -1 : 1);\n  const primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n  let primaryAxisArrowPosition;\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing ? popoverSizeOnPrimaryAxis : 0;\n  }\n  return {\n    primaryAxisPosition,\n    primaryAxisArrowPosition\n  };\n}\n\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\nexport function getElementBoundingBox(element) {\n  const rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width\n  };\n}\n\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\nexport function getAvailableSpace(anchorBoundingBox, containerBoundingBox, buffer, offset, offsetSide) {\n  const [topBuffer, rightBuffer, bottomBuffer, leftBuffer] = getBufferValues(buffer);\n  return {\n    top: anchorBoundingBox.top - containerBoundingBox.top - topBuffer - (offsetSide === 'top' ? offset : 0),\n    right: containerBoundingBox.right - anchorBoundingBox.right - rightBuffer - (offsetSide === 'right' ? offset : 0),\n    bottom: containerBoundingBox.bottom - anchorBoundingBox.bottom - bottomBuffer - (offsetSide === 'bottom' ? offset : 0),\n    left: anchorBoundingBox.left - containerBoundingBox.left - leftBuffer - (offsetSide === 'left' ? offset : 0)\n  };\n}\n\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\nexport function getVisibleFit(contentBoundingBox, containerBoundingBox) {\n  const intersection = intersectBoundingBoxes(contentBoundingBox, containerBoundingBox);\n  if (intersection.left > intersection.right || intersection.top > intersection.top) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n  const intersectionArea = (intersection.right - intersection.left) * (intersection.bottom - intersection.top);\n  const contentArea = (contentBoundingBox.right - contentBoundingBox.left) * (contentBoundingBox.bottom - contentBoundingBox.top);\n  return intersectionArea / contentArea;\n}\n\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\nexport function intersectBoundingBoxes(firstBox, secondBox) {\n  const top = Math.max(firstBox.top, secondBox.top);\n  const right = Math.min(firstBox.right, secondBox.right);\n  const bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  const left = Math.max(firstBox.left, secondBox.left);\n  const height = Math.max(bottom - top, 0);\n  const width = Math.max(right - left, 0);\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    height,\n    width\n  };\n}\n\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\nexport function getElementZIndex(element, cousin) {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n\n  // build the array of the element + its offset parents\n  const nodesToInspect = [];\n  while (true) {\n    nodesToInspect.push(element);\n\n    // AFAICT this is a valid cast - the libdefs appear wrong\n    element = element.offsetParent;\n\n    // stop if there is no parent\n    if (element == null) {\n      break;\n    }\n\n    // stop if the parent contains the related element\n    // as this is the z-index ancestor\n    if (element.contains(cousin)) {\n      break;\n    }\n  }\n\n  // reverse the nodes to walk from top -> element\n  nodesToInspect.reverse();\n  for (const node of nodesToInspect) {\n    // get this node's z-index css value\n    const zIndex = window.document.defaultView.getComputedStyle(node).getPropertyValue('z-index');\n\n    // if the z-index is not a number (e.g. \"auto\") return null, else the value\n    const parsedZIndex = parseInt(zIndex, 10);\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n  return 0;\n}","map":{"version":3,"names":["POSITIONS","relatedDimension","top","right","bottom","left","dimensionPositionAttribute","height","width","positionComplements","positionSubstitutes","getBufferValues","buffer","Array","isArray","topBuffer","rightBuffer","bottomBuffer","leftBuffer","findPopoverPosition","anchor","popover","align","position","forcePosition","offset","allowCrossAxis","container","arrowConfig","returnBoundingBox","anchorBoundingBox","getElementBoundingBox","popoverBoundingBox","documentWidth","document","documentElement","clientWidth","window","innerWidth","documentHeight","clientHeight","innerHeight","windowBoundingBox","containerBoundingBox","iterationPositions","iterationAlignments","push","undefined","bestFit","bestPosition","idx","length","iterationPosition","screenCoordinates","getPopoverScreenCoordinates","fit","pageYOffset","pageXOffset","arrow","Error","crossAxisFirstSide","crossAxisSecondSide","crossAxisDimension","crossAxisPosition","crossAxisArrowPosition","getCrossAxisPosition","primaryAxisDimension","primaryAxisPositionName","primaryAxisPosition","primaryAxisArrowPosition","getPrimaryAxisPosition","popoverPlacement","combinedBoundingBox","intersectBoundingBoxes","getVisibleFit","popoverSizeOnCrossAxis","anchorSizeOnCrossAxis","anchorHalfSize","crossAxisPositionOriginal","availableSpace","getAvailableSpace","minimumSpace","arrowBuffer","contentOverflowSize","alignAmount","alignDirection","amountOfShiftNeeded","shiftDirection","alignedOverflowAmount","needsShift","spaceAvailableOnFirstSide","spaceAvailableOnSecondSide","isShiftTowardFirstSide","leastAvailableSpace","Math","min","shiftAmount","arrowWidth","difference","edge","isOffsetDecreasing","popoverSizeOnPrimaryAxis","anchorEdgeOrigin","anchorSizeOnPrimaryAxis","primaryAxisOffset","contentOffset","element","rect","getBoundingClientRect","offsetSide","contentBoundingBox","intersection","intersectionArea","contentArea","firstBox","secondBox","max","getElementZIndex","cousin","nodesToInspect","offsetParent","contains","reverse","node","zIndex","defaultView","getComputedStyle","getPropertyValue","parsedZIndex","parseInt","isNaN"],"sources":["/Users/nikita/Downloads/super_date_picker/src/services/popover/popover_positioning.ts"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { EuiPopoverPosition } from './types';\n\ntype Dimension = 'height' | 'width';\n\nexport const POSITIONS: EuiPopoverPosition[] = [\n  'top',\n  'right',\n  'bottom',\n  'left',\n];\n\ninterface BoundingBox {\n  [position: string]: number;\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\nexport interface EuiClientRect extends BoundingBox {\n  height: number;\n  width: number;\n}\n\nconst relatedDimension: { [position in EuiPopoverPosition]: Dimension } = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width',\n};\n\nconst dimensionPositionAttribute: {\n  [dimension in Dimension]: 'top' | 'left';\n} = {\n  height: 'top',\n  width: 'left',\n};\n\nconst positionComplements: {\n  [position in EuiPopoverPosition]: EuiPopoverPosition;\n} = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n};\n\n// always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\nconst positionSubstitutes: {\n  [position in EuiPopoverPosition]: 'left' | 'top';\n} = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top',\n};\n\ninterface FindPopoverPositionArgs {\n  anchor: HTMLElement;\n  popover: HTMLElement;\n  align?: EuiPopoverPosition;\n  position: EuiPopoverPosition;\n  forcePosition?: boolean;\n  buffer?: number | [number, number, number, number];\n  offset?: number;\n  allowCrossAxis?: boolean;\n  container?: HTMLElement;\n  arrowConfig?: { arrowWidth: number; arrowBuffer: number };\n  returnBoundingBox?: boolean;\n}\n\ninterface FindPopoverPositionResult {\n  top: number;\n  left: number;\n  position: EuiPopoverPosition;\n  fit: number;\n  arrow?: { left: number; top: number };\n  anchorBoundingBox?: EuiClientRect;\n}\n\nconst getBufferValues = (\n  buffer: number | [number, number, number, number]\n): [number, number, number, number] => {\n  if (Array.isArray(buffer)) {\n    const [topBuffer, rightBuffer, bottomBuffer, leftBuffer] = buffer;\n    return [topBuffer, rightBuffer, bottomBuffer, leftBuffer];\n  }\n  return [buffer, buffer, buffer, buffer];\n};\n\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placement's relation to the anchor or undefined\n * there's no room.\n */\nexport function findPopoverPosition({\n  anchor,\n  popover,\n  align,\n  position,\n  forcePosition,\n  buffer = 16,\n  offset = 0,\n  allowCrossAxis = true,\n  container,\n  arrowConfig,\n  returnBoundingBox,\n}: FindPopoverPositionArgs): FindPopoverPositionResult {\n  // find the screen-relative bounding boxes of the anchor, popover, and container\n  const anchorBoundingBox = getElementBoundingBox(anchor);\n  const popoverBoundingBox = getElementBoundingBox(popover);\n\n  // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n  const documentWidth =\n    document.documentElement.clientWidth || window.innerWidth;\n  const documentHeight =\n    document.documentElement.clientHeight || window.innerHeight;\n  const windowBoundingBox: EuiClientRect = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth,\n  };\n\n  // if no container element is given fall back to using the window viewport\n  const containerBoundingBox = container\n    ? getElementBoundingBox(container)\n    : windowBoundingBox;\n\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n\n  // Try the user-desired position first.\n  const iterationPositions = [position];\n  // keep user-defined alignment in the original positions.\n  const iterationAlignments: Array<undefined | EuiPopoverPosition> = [align];\n\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(\n        positionSubstitutes[position], // Switch to the cross axis.\n        positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conflicts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (\n      position === align ||\n      (align !== undefined && position === positionComplements[align])\n    ) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n\n  let bestFit: number | undefined = undefined;\n  let bestPosition: FindPopoverPositionResult | null = null;\n\n  for (let idx = 0; idx < iterationPositions.length; idx++) {\n    const iterationPosition = iterationPositions[idx];\n\n    // See if we can find a position with a better fit than we've found so far.\n    const screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox,\n      popoverBoundingBox,\n      windowBoundingBox,\n      containerBoundingBox,\n      offset,\n      buffer,\n      arrowConfig,\n    });\n\n    if (bestFit === undefined || screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow,\n      };\n\n      // If we've already found the ideal fit, use that position.\n      if (bestFit === 1) {\n        break;\n      }\n    }\n\n    // If we haven't improved the fit, then continue on and try a new position.\n  }\n\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n\n  return bestPosition;\n}\n\ninterface GetPopoverScreenCoordinatesArgs {\n  position: EuiPopoverPosition;\n  align?: EuiPopoverPosition;\n  anchorBoundingBox: EuiClientRect;\n  popoverBoundingBox: EuiClientRect;\n  windowBoundingBox: EuiClientRect;\n  containerBoundingBox: EuiClientRect;\n  arrowConfig?: { arrowWidth: number; arrowBuffer: number };\n  offset?: number;\n  buffer?: number | [number, number, number, number];\n}\n\ninterface GetPopoverScreenCoordinatesResult {\n  top: number;\n  left: number;\n  fit: number;\n  arrow: { top: number; left: number } | undefined;\n}\n\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\nexport function getPopoverScreenCoordinates({\n  position,\n  align,\n  anchorBoundingBox,\n  popoverBoundingBox,\n  windowBoundingBox,\n  containerBoundingBox,\n  arrowConfig,\n  offset = 0,\n  buffer = 0,\n}: GetPopoverScreenCoordinatesArgs): GetPopoverScreenCoordinatesResult {\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n\n  const crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n  const crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n  const crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  const [topBuffer, rightBuffer, bottomBuffer, leftBuffer] = getBufferValues(\n    buffer\n  );\n\n  const { crossAxisPosition, crossAxisArrowPosition } = getCrossAxisPosition({\n    crossAxisFirstSide,\n    crossAxisSecondSide,\n    crossAxisDimension,\n    position,\n    align,\n    buffer,\n    offset,\n    windowBoundingBox,\n    containerBoundingBox,\n    popoverBoundingBox,\n    anchorBoundingBox,\n    arrowConfig,\n  });\n\n  const primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n  const primaryAxisPositionName =\n    dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  const {\n    primaryAxisPosition,\n    primaryAxisArrowPosition,\n  } = getPrimaryAxisPosition({\n    position,\n    offset,\n    popoverBoundingBox,\n    anchorBoundingBox,\n    arrowConfig,\n  });\n\n  const popoverPlacement = {\n    [crossAxisFirstSide]: crossAxisPosition,\n    [primaryAxisPositionName]: primaryAxisPosition,\n  };\n\n  // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n  const combinedBoundingBox = intersectBoundingBoxes(\n    windowBoundingBox,\n    containerBoundingBox\n  );\n\n  // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n  combinedBoundingBox.top += topBuffer;\n  combinedBoundingBox.right -= rightBuffer;\n  combinedBoundingBox.bottom -= bottomBuffer;\n  combinedBoundingBox.left += leftBuffer;\n\n  const fit = getVisibleFit(\n    {\n      top: popoverPlacement.top,\n      right: popoverPlacement.left + popoverBoundingBox.width,\n      bottom: popoverPlacement.top + popoverBoundingBox.height,\n      left: popoverPlacement.left,\n      width: popoverBoundingBox.width,\n      height: popoverBoundingBox.height,\n    },\n    combinedBoundingBox\n  );\n\n  const arrow = arrowConfig\n    ? {\n        [crossAxisFirstSide]:\n          crossAxisArrowPosition! - popoverPlacement[crossAxisFirstSide],\n        [primaryAxisPositionName]: primaryAxisArrowPosition,\n      }\n    : undefined;\n\n  return {\n    fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? { left: arrow.left!, top: arrow.top! } : undefined,\n  };\n}\n\ninterface GetCrossAxisPositionArgs {\n  crossAxisFirstSide: EuiPopoverPosition;\n  crossAxisSecondSide: EuiPopoverPosition;\n  crossAxisDimension: Dimension;\n  position: EuiPopoverPosition;\n  align?: EuiPopoverPosition;\n  buffer: number | [number, number, number, number];\n  offset: number;\n  windowBoundingBox: EuiClientRect;\n  containerBoundingBox: EuiClientRect;\n  popoverBoundingBox: EuiClientRect;\n  anchorBoundingBox: EuiClientRect;\n  arrowConfig?: { arrowWidth: number; arrowBuffer: number };\n}\n\ninterface CrossAxisPosition {\n  crossAxisPosition: number;\n  crossAxisArrowPosition: number | undefined;\n}\n\nfunction getCrossAxisPosition({\n  crossAxisFirstSide,\n  crossAxisSecondSide,\n  crossAxisDimension,\n  position,\n  align,\n  buffer,\n  offset,\n  windowBoundingBox,\n  containerBoundingBox,\n  popoverBoundingBox,\n  anchorBoundingBox,\n  arrowConfig,\n}: GetCrossAxisPositionArgs): CrossAxisPosition {\n  // how much of the popover overflows past either side of the anchor if its centered\n  const popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  const anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  const anchorHalfSize = anchorSizeOnCrossAxis / 2;\n\n  // the popover's original position on the cross-axis is determined by:\n  const crossAxisPositionOriginal =\n    anchorBoundingBox[crossAxisFirstSide] + // where the anchor is located\n    anchorHalfSize - // plus half anchor dimension\n    popoverSizeOnCrossAxis / 2; // less half the popover dimension\n\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n  const combinedBoundingBox = intersectBoundingBoxes(\n    windowBoundingBox,\n    containerBoundingBox\n  );\n  const availableSpace = getAvailableSpace(\n    anchorBoundingBox,\n    combinedBoundingBox,\n    buffer,\n    offset,\n    position\n  );\n  const minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n\n  const contentOverflowSize =\n    (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n\n  let alignAmount = 0;\n  let alignDirection = 1;\n  let amountOfShiftNeeded = 0;\n  let shiftDirection = 1;\n\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n\n    const alignedOverflowAmount = contentOverflowSize + alignAmount;\n    const needsShift =\n      alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift\n      ? alignedOverflowAmount - availableSpace[positionComplements[align]]\n      : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    const spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    const spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n\n    const isShiftTowardFirstSide =\n      spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1;\n\n    // determine which direction has more room and the popover should shift to\n    const leastAvailableSpace = Math.min(\n      spaceAvailableOnFirstSide,\n      spaceAvailableOnSecondSide\n    );\n\n    const needsShift = contentOverflowSize > leastAvailableSpace;\n    amountOfShiftNeeded = needsShift\n      ? contentOverflowSize - leastAvailableSpace\n      : 0;\n  }\n\n  // shift over the popover if necessary\n  const shiftAmount = amountOfShiftNeeded * shiftDirection;\n  let crossAxisPosition =\n    crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection;\n\n  // if an `arrowConfig` is specified, find where to position the arrow\n  let crossAxisArrowPosition;\n  if (arrowConfig) {\n    const { arrowWidth } = arrowConfig;\n    crossAxisArrowPosition =\n      anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - arrowWidth / 2;\n\n    // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      const difference =\n        crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (\n      crossAxisArrowPosition + minimumSpace + arrowWidth >\n      crossAxisPosition + popoverSizeOnCrossAxis\n    ) {\n      // arrow is too close to the maximum side\n      const edge = crossAxisPosition + popoverSizeOnCrossAxis;\n      const difference =\n        crossAxisArrowPosition - (edge - minimumSpace - arrowWidth);\n      crossAxisPosition += difference;\n    }\n  }\n\n  return {\n    crossAxisPosition,\n    crossAxisArrowPosition,\n  };\n}\n\ninterface GetPrimaryAxisPositionArgs {\n  position: EuiPopoverPosition;\n  offset: number;\n  popoverBoundingBox: BoundingBox;\n  anchorBoundingBox: BoundingBox;\n  arrowConfig?: { arrowWidth: number; arrowBuffer: number };\n}\n\nfunction getPrimaryAxisPosition({\n  position,\n  offset,\n  popoverBoundingBox,\n  anchorBoundingBox,\n  arrowConfig,\n}: GetPrimaryAxisPositionArgs) {\n  // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n  const isOffsetDecreasing = position === 'top' || position === 'left';\n\n  const primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n  const popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension];\n\n  // start at the top or left edge of the anchor element\n  const primaryAxisPositionName =\n    dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n  const anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName];\n\n  // find the popover position on the primary axis\n  const anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  const primaryAxisOffset = isOffsetDecreasing\n    ? popoverSizeOnPrimaryAxis\n    : anchorSizeOnPrimaryAxis;\n  const contentOffset =\n    (offset + primaryAxisOffset!) * (isOffsetDecreasing ? -1 : 1);\n  const primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n\n  let primaryAxisArrowPosition;\n\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing\n      ? popoverSizeOnPrimaryAxis\n      : 0;\n  }\n\n  return {\n    primaryAxisPosition,\n    primaryAxisArrowPosition,\n  };\n}\n\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\nexport function getElementBoundingBox(element: HTMLElement): EuiClientRect {\n  const rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width,\n  };\n}\n\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\nexport function getAvailableSpace(\n  anchorBoundingBox: BoundingBox,\n  containerBoundingBox: BoundingBox,\n  buffer: number | [number, number, number, number],\n  offset: number,\n  offsetSide: EuiPopoverPosition\n): BoundingBox {\n  const [topBuffer, rightBuffer, bottomBuffer, leftBuffer] = getBufferValues(\n    buffer\n  );\n  return {\n    top:\n      anchorBoundingBox.top -\n      containerBoundingBox.top -\n      topBuffer -\n      (offsetSide === 'top' ? offset : 0),\n    right:\n      containerBoundingBox.right -\n      anchorBoundingBox.right -\n      rightBuffer -\n      (offsetSide === 'right' ? offset : 0),\n    bottom:\n      containerBoundingBox.bottom -\n      anchorBoundingBox.bottom -\n      bottomBuffer -\n      (offsetSide === 'bottom' ? offset : 0),\n    left:\n      anchorBoundingBox.left -\n      containerBoundingBox.left -\n      leftBuffer -\n      (offsetSide === 'left' ? offset : 0),\n  };\n}\n\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\nexport function getVisibleFit(\n  contentBoundingBox: BoundingBox,\n  containerBoundingBox: BoundingBox\n): number {\n  const intersection = intersectBoundingBoxes(\n    contentBoundingBox,\n    containerBoundingBox\n  );\n\n  if (\n    intersection.left > intersection.right ||\n    intersection.top > intersection.top\n  ) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n\n  const intersectionArea =\n    (intersection.right - intersection.left) *\n    (intersection.bottom - intersection.top);\n  const contentArea =\n    (contentBoundingBox.right - contentBoundingBox.left) *\n    (contentBoundingBox.bottom - contentBoundingBox.top);\n\n  return intersectionArea / contentArea;\n}\n\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\nexport function intersectBoundingBoxes(\n  firstBox: BoundingBox,\n  secondBox: BoundingBox\n): EuiClientRect {\n  const top = Math.max(firstBox.top, secondBox.top);\n  const right = Math.min(firstBox.right, secondBox.right);\n  const bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  const left = Math.max(firstBox.left, secondBox.left);\n  const height = Math.max(bottom - top, 0);\n  const width = Math.max(right - left, 0);\n\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    height,\n    width,\n  };\n}\n\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\nexport function getElementZIndex(\n  element: HTMLElement,\n  cousin: HTMLElement\n): number {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n\n  // build the array of the element + its offset parents\n  const nodesToInspect: HTMLElement[] = [];\n  while (true) {\n    nodesToInspect.push(element);\n\n    // AFAICT this is a valid cast - the libdefs appear wrong\n    element = element.offsetParent as HTMLElement;\n\n    // stop if there is no parent\n    if (element == null) {\n      break;\n    }\n\n    // stop if the parent contains the related element\n    // as this is the z-index ancestor\n    if (element.contains(cousin)) {\n      break;\n    }\n  }\n\n  // reverse the nodes to walk from top -> element\n  nodesToInspect.reverse();\n\n  for (const node of nodesToInspect) {\n    // get this node's z-index css value\n    const zIndex = window.document\n      .defaultView!.getComputedStyle(node)\n      .getPropertyValue('z-index');\n\n    // if the z-index is not a number (e.g. \"auto\") return null, else the value\n    const parsedZIndex = parseInt(zIndex, 10);\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n\n  return 0;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}