{"ast":null,"code":"var _jsxFileName = \"/Users/nikita/Downloads/super_date_picker/src/popover/popover.tsx\";\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { Component } from \"react\";\n/** @jsxImportSource @emotion/react */\nimport { focusable } from \"tabbable\";\nimport classNames from \"classnames\";\nimport { EuiFocusTrap } from \"../focus_trap\";\nimport { cascadingMenuKeys, getTransitionTimings, getWaitDuration, performOnFrame, htmlIdGenerator } from \"../services\";\nimport { EuiPortal } from \"../portal\";\nimport { EuiMutationObserver } from \"../observer/mutation_observer\";\nimport { findPopoverPosition, getElementZIndex } from \"../services/popover\";\nimport { EuiOutsideClickDetector } from \"../outside_click_detector\";\nimport { EuiPopoverArrow } from \"./popover_arrow\";\nimport { euiPopoverStyles } from \"./popover.styles\";\nimport { EuiPopoverPanel } from \"./popover_panel\";\nimport { jsxDEV as _jsxDEV } from \"@emotion/react/jsx-dev-runtime\";\nexport const popoverAnchorPosition = [\"upCenter\", \"upLeft\", \"upRight\", \"downCenter\", \"downLeft\", \"downRight\", \"leftCenter\", \"leftUp\", \"leftDown\", \"rightCenter\", \"rightUp\", \"rightDown\"];\nconst anchorPositionToPopoverPositionMap = {\n  up: \"top\",\n  right: \"right\",\n  down: \"bottom\",\n  left: \"left\"\n};\nexport function getPopoverPositionFromAnchorPosition(anchorPosition) {\n  // maps the anchor position to the matching popover position\n  // e.g. \"upLeft\" -> \"top\", \"downRight\" -> \"bottom\"\n\n  // extract the first positional word from anchorPosition:\n  // starts at the beginning (\" ^ \") of anchorPosition and\n  // captures all of the characters (\" (.*?) \") until the\n  // first capital letter (\" [A-Z] \") is encountered\n  const [, primaryPosition] = anchorPosition.match(/^(.*?)[A-Z]/);\n  return anchorPositionToPopoverPositionMap[primaryPosition];\n}\nexport function getPopoverAlignFromAnchorPosition(anchorPosition) {\n  // maps the gravity to the matching popover position\n  // e.g. \"upLeft\" -> \"left\", \"rightDown\" -> \"bottom\"\n\n  // extract the second positional word from anchorPosition:\n  // starts a capture group at the first capital letter\n  // and includes everything after it\n  const [, align] = anchorPosition.match(/([A-Z].*)/);\n\n  // this performs two tasks:\n  // 1. normalizes the align position by lowercasing it\n  // 2. `center` doesn't exist in the lookup map which converts it to `undefined` meaning no align\n  return anchorPositionToPopoverPositionMap[align.toLowerCase()];\n}\nconst DEFAULT_POPOVER_STYLES = {\n  top: 50,\n  left: 50\n};\nconst returnFocusConfig = {\n  preventScroll: true\n};\nconst closingTransitionTime = 250; // TODO: DRY out var when converting to CSS-in-JS\n\nexport class EuiPopover extends Component {\n  static getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevProps.isOpen && !nextProps.isOpen) {\n      return {\n        prevProps: {\n          isOpen: nextProps.isOpen\n        },\n        isClosing: true,\n        isOpening: false\n      };\n    }\n    if (prevState.prevProps.isOpen !== nextProps.isOpen) {\n      return {\n        prevProps: {\n          isOpen: nextProps.isOpen\n        }\n      };\n    }\n    return null;\n  }\n  constructor(props) {\n    super(props);\n    this.respositionTimeout = void 0;\n    this.strandedFocusTimeout = void 0;\n    this.closingTransitionTimeout = void 0;\n    this.closingTransitionAnimationFrame = void 0;\n    this.button = null;\n    this.panel = null;\n    this.descriptionId = htmlIdGenerator()();\n    this.closePopover = () => {\n      if (this.props.isOpen) {\n        this.props.closePopover();\n      }\n    };\n    this.onEscapeKey = event => {\n      if (this.props.isOpen) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.closePopover();\n        this.handleStrandedFocus();\n      }\n    };\n    this.handleStrandedFocus = () => {\n      this.strandedFocusTimeout = window.setTimeout(() => {\n        // If `returnFocus` failed and focus was stranded on the body,\n        // attempt to manually restore focus to the toggle button\n        if (document.activeElement === document.body) {\n          if (!this.button) return;\n          const focusableItems = focusable(this.button);\n          if (!focusableItems.length) return;\n          const toggleButton = focusableItems[0];\n          toggleButton.focus(returnFocusConfig);\n        }\n      }, closingTransitionTime);\n    };\n    this.onKeyDown = event => {\n      if (event.key === cascadingMenuKeys.ESCAPE) {\n        this.onEscapeKey(event);\n      }\n    };\n    this.onClickOutside = event => {\n      // only close the popover if the event source isn't the anchor button\n      // otherwise, it is up to the anchor to toggle the popover's open status\n      if (this.button && this.button.contains(event.target) === false) {\n        this.closePopover();\n      }\n    };\n    this.onOpenPopover = () => {\n      clearTimeout(this.strandedFocusTimeout);\n      clearTimeout(this.closingTransitionTimeout);\n      if (this.closingTransitionAnimationFrame) {\n        cancelAnimationFrame(this.closingTransitionAnimationFrame);\n      }\n      // We need to set this state a beat after the render takes place, so that the CSS\n      // transition can take effect.\n      this.closingTransitionAnimationFrame = window.requestAnimationFrame(() => {\n        this.setState({\n          isOpening: true\n        });\n      });\n\n      // for each child element of `this.panel`, find any transition duration we should wait for before stabilizing\n      const {\n        durationMatch,\n        delayMatch\n      } = Array.prototype.slice.call(this.panel ? [this.panel, ...Array.from(this.panel.children)] : []).reduce((_ref, element) => {\n        let {\n          durationMatch,\n          delayMatch\n        } = _ref;\n        const transitionTimings = getTransitionTimings(element);\n        return {\n          durationMatch: Math.max(durationMatch, transitionTimings.durationMatch),\n          delayMatch: Math.max(delayMatch, transitionTimings.delayMatch)\n        };\n      }, {\n        durationMatch: 0,\n        delayMatch: 0\n      });\n      clearTimeout(this.respositionTimeout);\n      this.respositionTimeout = window.setTimeout(() => {\n        this.setState({\n          isOpenStable: true\n        }, () => {\n          this.positionPopoverFixed();\n        });\n      }, durationMatch + delayMatch);\n    };\n    this.onMutation = records => {\n      const waitDuration = getWaitDuration(records);\n      this.positionPopoverFixed();\n      performOnFrame(waitDuration, this.positionPopoverFixed);\n    };\n    this.positionPopover = allowEnforcePosition => {\n      if (this.button == null || this.panel == null) return;\n      const {\n        anchorPosition\n      } = this.props;\n      let position = getPopoverPositionFromAnchorPosition(anchorPosition);\n      let forcePosition = undefined;\n      if (allowEnforcePosition && this.state.isOpenStable && this.state.openPosition != null) {\n        position = this.state.openPosition;\n        forcePosition = true;\n      }\n      const {\n        top,\n        left,\n        position: foundPosition,\n        arrow,\n        anchorBoundingBox\n      } = findPopoverPosition({\n        container: this.props.container,\n        position,\n        forcePosition,\n        align: getPopoverAlignFromAnchorPosition(anchorPosition),\n        anchor: this.button,\n        popover: this.panel,\n        offset: !this.props.attachToAnchor && this.props.hasArrow ? 16 + (this.props.offset || 0) : 8 + (this.props.offset || 0),\n        arrowConfig: {\n          arrowWidth: 24,\n          arrowBuffer: 10\n        },\n        returnBoundingBox: this.props.attachToAnchor,\n        buffer: this.props.buffer\n      });\n\n      // the popover's z-index must inherit from the button\n      // this keeps a button's popover under a flyout that would cover the button\n      // but a popover triggered inside a flyout will appear over that flyout\n      const {\n        zIndex: zIndexProp\n      } = this.props;\n      const zIndex = zIndexProp == null ? getElementZIndex(this.button, this.panel) + 2000 : zIndexProp;\n      const popoverStyles = {\n        ...this.props.panelStyle,\n        top,\n        left: this.props.attachToAnchor && anchorBoundingBox ? anchorBoundingBox.left : left,\n        zIndex\n      };\n      const willRenderArrow = !this.props.attachToAnchor && this.props.hasArrow;\n      const arrowStyles = willRenderArrow ? arrow : undefined;\n      const arrowPosition = foundPosition;\n      this.props.onPositionChange && this.props.onPositionChange(arrowPosition);\n      this.setState({\n        popoverStyles,\n        arrowStyles,\n        arrowPosition,\n        openPosition: foundPosition\n      });\n    };\n    this.positionPopoverFixed = () => {\n      this.positionPopover(true);\n    };\n    this.positionPopoverFluid = () => {\n      this.positionPopover(false);\n    };\n    this.panelRef = node => {\n      this.panel = node;\n      this.props.panelRef && this.props.panelRef(node);\n      if (node == null) {\n        // panel has unmounted, restore the state defaults\n        this.setState({\n          popoverStyles: DEFAULT_POPOVER_STYLES,\n          arrowStyles: {},\n          arrowPosition: null,\n          openPosition: null,\n          isOpenStable: false\n        });\n        window.removeEventListener(\"resize\", this.positionPopoverFluid);\n      } else {\n        // panel is coming into existence\n        this.positionPopoverFluid();\n        window.addEventListener(\"resize\", this.positionPopoverFluid);\n      }\n    };\n    this.buttonRef = node => {\n      this.button = node;\n      this.props.buttonRef && this.props.buttonRef(node);\n    };\n    this.state = {\n      prevProps: {\n        isOpen: props.isOpen\n      },\n      suppressingPopover: props.isOpen,\n      // only suppress if created with isOpen=true\n      isClosing: false,\n      isOpening: false,\n      popoverStyles: DEFAULT_POPOVER_STYLES,\n      arrowStyles: {},\n      arrowPosition: null,\n      openPosition: null,\n      // once a stable position has been found, keep the contents on that side\n      isOpenStable: false // wait for any initial opening transitions to finish before marking as stable\n    };\n  }\n\n  componentDidMount() {\n    if (this.state.suppressingPopover) {\n      // component was created with isOpen=true; now that it's mounted\n      // stop suppressing and start opening\n      // eslint-disable-next-line react/no-did-mount-set-state\n      this.setState({\n        suppressingPopover: false,\n        isOpening: true\n      }, () => {\n        this.onOpenPopover();\n      });\n    }\n    if (this.props.repositionOnScroll) {\n      window.addEventListener(\"scroll\", this.positionPopoverFixed, true);\n    }\n  }\n  componentDidUpdate(prevProps) {\n    // The popover is being opened.\n    if (!prevProps.isOpen && this.props.isOpen) {\n      this.onOpenPopover();\n    }\n\n    // update scroll listener\n    if (prevProps.repositionOnScroll !== this.props.repositionOnScroll) {\n      if (this.props.repositionOnScroll) {\n        window.addEventListener(\"scroll\", this.positionPopoverFixed, true);\n      } else {\n        window.removeEventListener(\"scroll\", this.positionPopoverFixed, true);\n      }\n    }\n\n    // The popover is being closed.\n    if (prevProps.isOpen && !this.props.isOpen) {\n      // If the user has just closed the popover, queue up the removal of the content after the\n      // transition is complete.\n      this.closingTransitionTimeout = window.setTimeout(() => {\n        this.setState({\n          isClosing: false\n        });\n      }, closingTransitionTime);\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener(\"scroll\", this.positionPopoverFixed, true);\n    clearTimeout(this.respositionTimeout);\n    clearTimeout(this.strandedFocusTimeout);\n    clearTimeout(this.closingTransitionTimeout);\n    cancelAnimationFrame(this.closingTransitionAnimationFrame);\n  }\n  render() {\n    var _panelProps$tabIndex;\n    const {\n      anchorClassName,\n      anchorPosition,\n      button,\n      buttonRef,\n      insert,\n      isOpen,\n      ownFocus,\n      children,\n      className,\n      closePopover,\n      panelClassName,\n      panelPaddingSize,\n      panelProps,\n      panelRef,\n      panelStyle,\n      popoverScreenReaderText,\n      popoverRef,\n      hasArrow,\n      arrowChildren,\n      repositionOnScroll,\n      hasDragDrop,\n      zIndex,\n      attachToAnchor,\n      display,\n      offset,\n      onPositionChange,\n      onTrapDeactivation,\n      buffer,\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledBy,\n      container,\n      focusTrapProps,\n      initialFocus: initialFocusProp,\n      tabIndex: _tabIndexProp,\n      ...rest\n    } = this.props;\n    const tabIndexProp = (_panelProps$tabIndex = panelProps === null || panelProps === void 0 ? void 0 : panelProps.tabIndex) !== null && _panelProps$tabIndex !== void 0 ? _panelProps$tabIndex : _tabIndexProp;\n    const styles = euiPopoverStyles();\n    const popoverStyles = [styles.euiPopover, {\n      display\n    }];\n    const classes = classNames(\"euiPopover\", {\n      \"euiPopover-isOpen\": this.state.isOpening\n    }, className);\n    const anchorClasses = classNames(\"euiPopover__anchor\", anchorClassName);\n    const showArrow = hasArrow && !attachToAnchor;\n    let panel;\n    if (!this.state.suppressingPopover && (isOpen || this.state.isClosing)) {\n      let tabIndex = tabIndexProp;\n      let initialFocus = initialFocusProp;\n      let ariaDescribedby;\n      let ariaLive;\n      const panelAriaModal = panelProps !== null && panelProps !== void 0 && panelProps.hasOwnProperty(\"aria-modal\") ? panelProps[\"aria-modal\"] : \"true\";\n      const panelRole = panelProps !== null && panelProps !== void 0 && panelProps.hasOwnProperty(\"role\") ? panelProps.role : \"dialog\";\n      if (ownFocus || panelAriaModal !== \"true\") {\n        tabIndex = tabIndexProp !== null && tabIndexProp !== void 0 ? tabIndexProp : 0;\n        ariaLive = \"off\";\n        if (!initialFocus) {\n          initialFocus = () => this.panel;\n        }\n      } else {\n        ariaLive = \"assertive\";\n      }\n      let focusTrapScreenReaderText;\n      if (ownFocus || popoverScreenReaderText) {\n        ariaDescribedby = this.descriptionId;\n      }\n      const returnFocus = this.state.isOpenStable ? returnFocusConfig : false;\n      panel = _jsxDEV(EuiPortal, {\n        insert: insert,\n        children: _jsxDEV(EuiFocusTrap, {\n          clickOutsideDisables: true,\n          ...focusTrapProps,\n          returnFocus: returnFocus // Ignore temporary state of indecisive focus\n          ,\n          initialFocus: initialFocus,\n          onDeactivation: onTrapDeactivation,\n          onClickOutside: this.onClickOutside,\n          onEscapeKey: this.onEscapeKey,\n          disabled: !ownFocus || !this.state.isOpenStable || this.state.isClosing,\n          children: _jsxDEV(EuiPopoverPanel, {\n            ...panelProps,\n            panelRef: this.panelRef,\n            isOpen: this.state.isOpening,\n            position: this.state.arrowPosition,\n            isAttached: attachToAnchor,\n            className: classNames(panelClassName, panelProps === null || panelProps === void 0 ? void 0 : panelProps.className),\n            hasDragDrop: hasDragDrop,\n            hasShadow: false,\n            paddingSize: panelPaddingSize,\n            tabIndex: tabIndex,\n            \"aria-live\": ariaLive,\n            role: panelRole,\n            \"aria-label\": ariaLabel,\n            \"aria-labelledby\": ariaLabelledBy,\n            \"aria-modal\": panelAriaModal,\n            \"aria-describedby\": ariaDescribedby,\n            style: {\n              ...this.state.popoverStyles,\n              // Adding `will-change` to reduce risk of a blurry animation in Chrome 86+\n              willChange: !this.state.isOpenStable ? \"transform, opacity\" : undefined\n            },\n            children: [showArrow && this.state.arrowPosition && _jsxDEV(EuiPopoverArrow, {\n              position: this.state.arrowPosition,\n              style: this.state.arrowStyles,\n              children: arrowChildren\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 722,\n              columnNumber: 17\n            }, this), focusTrapScreenReaderText, _jsxDEV(EuiMutationObserver, {\n              observerOptions: {\n                attributes: true,\n                // element attribute changes\n                childList: true,\n                // added/removed elements\n                characterData: true,\n                // text changes\n                subtree: true // watch all child elements\n              },\n\n              onMutation: this.onMutation,\n              children: mutationRef => _jsxDEV(\"div\", {\n                ref: mutationRef,\n                children: children\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 739,\n                columnNumber: 35\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 730,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 696,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 684,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 683,\n        columnNumber: 9\n      }, this);\n    }\n\n    // react-focus-on and related do not register outside click detection\n    // when disabled, so we still need to conditionally check for that ourselves\n    if (ownFocus) {\n      return _jsxDEV(\"div\", {\n        css: popoverStyles,\n        className: classes,\n        ref: popoverRef,\n        ...rest,\n        children: [_jsxDEV(\"div\", {\n          css: {\n            display\n          },\n          className: anchorClasses,\n          ref: this.buttonRef,\n          children: button instanceof HTMLElement ? null : button\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 752,\n          columnNumber: 11\n        }, this), panel]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 751,\n        columnNumber: 9\n      }, this);\n    } else {\n      return _jsxDEV(EuiOutsideClickDetector, {\n        onOutsideClick: this.closePopover,\n        children: _jsxDEV(\"div\", {\n          css: popoverStyles,\n          className: classes,\n          ref: popoverRef,\n          onKeyDown: this.onKeyDown,\n          ...rest,\n          children: [_jsxDEV(\"div\", {\n            css: {\n              display\n            },\n            className: anchorClasses,\n            ref: this.buttonRef,\n            children: button instanceof HTMLElement ? null : button\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 768,\n            columnNumber: 13\n          }, this), panel]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 761,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 760,\n        columnNumber: 9\n      }, this);\n    }\n  }\n}\nEuiPopover.defaultProps = {\n  isOpen: false,\n  ownFocus: true,\n  anchorPosition: \"downCenter\",\n  panelPaddingSize: \"m\",\n  hasArrow: true,\n  display: \"inline-block\"\n};","map":{"version":3,"names":["Component","focusable","classNames","EuiFocusTrap","cascadingMenuKeys","getTransitionTimings","getWaitDuration","performOnFrame","htmlIdGenerator","EuiPortal","EuiMutationObserver","findPopoverPosition","getElementZIndex","EuiOutsideClickDetector","EuiPopoverArrow","euiPopoverStyles","EuiPopoverPanel","popoverAnchorPosition","anchorPositionToPopoverPositionMap","up","right","down","left","getPopoverPositionFromAnchorPosition","anchorPosition","primaryPosition","match","getPopoverAlignFromAnchorPosition","align","toLowerCase","DEFAULT_POPOVER_STYLES","top","returnFocusConfig","preventScroll","closingTransitionTime","EuiPopover","getDerivedStateFromProps","nextProps","prevState","prevProps","isOpen","isClosing","isOpening","constructor","props","respositionTimeout","strandedFocusTimeout","closingTransitionTimeout","closingTransitionAnimationFrame","button","panel","descriptionId","closePopover","onEscapeKey","event","preventDefault","stopPropagation","handleStrandedFocus","window","setTimeout","document","activeElement","body","focusableItems","length","toggleButton","focus","onKeyDown","key","ESCAPE","onClickOutside","contains","target","onOpenPopover","clearTimeout","cancelAnimationFrame","requestAnimationFrame","setState","durationMatch","delayMatch","Array","prototype","slice","call","from","children","reduce","element","transitionTimings","Math","max","isOpenStable","positionPopoverFixed","onMutation","records","waitDuration","positionPopover","allowEnforcePosition","position","forcePosition","undefined","state","openPosition","foundPosition","arrow","anchorBoundingBox","container","anchor","popover","offset","attachToAnchor","hasArrow","arrowConfig","arrowWidth","arrowBuffer","returnBoundingBox","buffer","zIndex","zIndexProp","popoverStyles","panelStyle","willRenderArrow","arrowStyles","arrowPosition","onPositionChange","positionPopoverFluid","panelRef","node","removeEventListener","addEventListener","buttonRef","suppressingPopover","componentDidMount","repositionOnScroll","componentDidUpdate","componentWillUnmount","render","anchorClassName","insert","ownFocus","className","panelClassName","panelPaddingSize","panelProps","popoverScreenReaderText","popoverRef","arrowChildren","hasDragDrop","display","onTrapDeactivation","ariaLabel","ariaLabelledBy","focusTrapProps","initialFocus","initialFocusProp","tabIndex","_tabIndexProp","rest","tabIndexProp","styles","euiPopover","classes","anchorClasses","showArrow","ariaDescribedby","ariaLive","panelAriaModal","hasOwnProperty","panelRole","role","focusTrapScreenReaderText","returnFocus","willChange","attributes","childList","characterData","subtree","mutationRef","HTMLElement","defaultProps"],"sources":["/Users/nikita/Downloads/super_date_picker/src/popover/popover.tsx"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport {\n  Component,\n  KeyboardEvent,\n  CSSProperties,\n  HTMLAttributes,\n  ReactNode,\n  Ref,\n  RefCallback,\n} from \"react\";\n/** @jsxImportSource @emotion/react */\nimport { focusable } from \"tabbable\";\nimport classNames from \"classnames\";\n\nimport { CommonProps, NoArgCallback } from \"../common\";\nimport { FocusTarget, EuiFocusTrap, EuiFocusTrapProps } from \"../focus_trap\";\nimport { ReactFocusOnProps } from \"react-focus-on/dist/es5/types\";\n\nimport {\n  cascadingMenuKeys,\n  getTransitionTimings,\n  getWaitDuration,\n  performOnFrame,\n  htmlIdGenerator,\n} from \"../services\";\n\nimport { EuiPortal } from \"../portal\";\n\nimport { EuiMutationObserver } from \"../observer/mutation_observer\";\n\nimport {\n  findPopoverPosition,\n  getElementZIndex,\n  EuiPopoverPosition,\n} from \"../services/popover\";\n\nimport { EuiOutsideClickDetector } from \"../outside_click_detector\";\nimport { EuiPopoverArrow, EuiPopoverArrowPositions } from \"./popover_arrow\";\nimport { euiPopoverStyles } from \"./popover.styles\";\nimport { EuiPopoverPanel } from \"./popover_panel\";\nimport { EuiPopoverPanelProps } from \"./popover_panel/_popover_panel\";\nimport { EuiPaddingSize } from \"../global_styling\";\n\nexport const popoverAnchorPosition = [\n  \"upCenter\",\n  \"upLeft\",\n  \"upRight\",\n  \"downCenter\",\n  \"downLeft\",\n  \"downRight\",\n  \"leftCenter\",\n  \"leftUp\",\n  \"leftDown\",\n  \"rightCenter\",\n  \"rightUp\",\n  \"rightDown\",\n] as const;\n\nexport type PopoverAnchorPosition = typeof popoverAnchorPosition[number];\ntype AnchorPosition = \"up\" | \"right\" | \"down\" | \"left\";\n\nexport interface EuiPopoverProps extends CommonProps {\n  /**\n   * Class name passed to the direct parent of the button\n   */\n  anchorClassName?: string;\n  /**\n   * Alignment of the popover and arrow relative to the button\n   */\n  anchorPosition?: PopoverAnchorPosition;\n  /**\n   * Style and position alteration for arrow-less, left-aligned\n   * attachment. Intended for use with inputs as anchors, e.g.\n   * EuiInputPopover\n   */\n  attachToAnchor?: boolean;\n  /**\n   * Triggering element for which to align the popover to\n   */\n  button: NonNullable<ReactNode>;\n  buttonRef?: RefCallback<HTMLDivElement>;\n  /**\n   * Callback to handle hiding of the popover\n   */\n  closePopover: NoArgCallback<void>;\n  /**\n   * Restrict the popover's position within this element\n   */\n  container?: HTMLElement;\n  /**\n   * CSS display type for both the popover and anchor\n   */\n  display?: CSSProperties[\"display\"];\n  /**\n   * Object of props passed to EuiFocusTrap\n   */\n  focusTrapProps?: Pick<\n    EuiFocusTrapProps,\n    \"clickOutsideDisables\" | \"noIsolation\" | \"scrollLock\" | \"shards\"\n  >;\n  /**\n   * Show arrow indicating to originating button\n   */\n  hasArrow?: boolean;\n  /**\n   * Specifies what element should initially have focus; Can be a DOM\n   * node, or a selector string (which will be passed to\n   * document.querySelector() to find the DOM node), or a function that\n   * returns a DOM node.\n   *\n   * If not passed, initial focus defaults to the popover panel.\n   */\n  initialFocus?: FocusTarget;\n  /**\n   * Passed directly to EuiPortal for DOM positioning. Both properties are\n   * required if prop is specified\n   */\n  insert?: {\n    sibling: HTMLElement;\n    position: \"before\" | \"after\";\n  };\n  /**\n   * Visibility state of the popover\n   */\n  isOpen?: boolean;\n  /**\n   * Traps tab focus within the popover contents\n   */\n  ownFocus?: boolean;\n  /**\n   * Custom class added to the EuiPanel containing the popover contents\n   */\n  panelClassName?: string;\n  /**\n   * EuiPanel padding on all sides\n   */\n  panelPaddingSize?: EuiPaddingSize;\n  /**\n   * Standard DOM `style` attribute. Passed to the EuiPanel\n   */\n  panelStyle?: CSSProperties;\n  /**\n   * Object of props passed to EuiPanel. See #EuiPopoverPanelProps\n   */\n  panelProps?: Omit<EuiPopoverPanelProps, \"style\">;\n  panelRef?: RefCallback<HTMLElement | null>;\n  /**\n   * Optional screen reader instructions to announce upon popover open,\n   * in addition to EUI's default popover instructions for Escape on close.\n   * Useful for popovers that may have additional keyboard capabilities such as\n   * arrow navigation.\n   */\n  popoverScreenReaderText?: string | ReactNode;\n  popoverRef?: Ref<HTMLDivElement>;\n  /**\n   * When `true`, the popover's position is re-calculated when the user\n   * scrolls, this supports having fixed-position popover anchors. When nesting\n   * an `EuiPopover` in a scrollable container, `repositionOnScroll` should be `true`\n   */\n  repositionOnScroll?: boolean;\n  /**\n   * Must be set to true if using `EuiDragDropContext` within a popover,\n   * otherwise your nested drag & drop will have incorrect positioning\n   */\n  hasDragDrop?: boolean;\n  /**\n   * By default, popover content inherits the z-index of the anchor\n   * component; pass `zIndex` to override\n   */\n  zIndex?: number;\n  /**\n   * Function callback for when the focus trap is deactivated\n   */\n  onTrapDeactivation?: ReactFocusOnProps[\"onDeactivation\"];\n  /**\n   * Distance away from the anchor that the popover will render\n   */\n  offset?: number;\n  /**\n   * Minimum distance between the popover and the bounding container;\n   * Pass an array of 4 values to adjust each side differently: `[top, right, bottom, left]`\n   * Default is 16\n   */\n  buffer?: number | [number, number, number, number];\n  /**\n   * Element to pass as the child element of the arrow;\n   * Use case is typically limited to an accompanying `EuiBeacon`\n   */\n  arrowChildren?: ReactNode;\n  /**\n   * Provide a name to the popover panel\n   */\n  \"aria-label\"?: string;\n  /**\n   * Alternative option to `aria-label` that takes an `id`.\n   * Usually takes the `id` of the popover title\n   */\n  \"aria-labelledby\"?: string;\n  /**\n   * Function callback for when the popover positon changes\n   */\n  onPositionChange?: (position: EuiPopoverPosition) => void;\n}\n\nconst anchorPositionToPopoverPositionMap: {\n  [position in AnchorPosition]: EuiPopoverPosition;\n} = {\n  up: \"top\",\n  right: \"right\",\n  down: \"bottom\",\n  left: \"left\",\n};\n\nexport function getPopoverPositionFromAnchorPosition(\n  anchorPosition: PopoverAnchorPosition\n) {\n  // maps the anchor position to the matching popover position\n  // e.g. \"upLeft\" -> \"top\", \"downRight\" -> \"bottom\"\n\n  // extract the first positional word from anchorPosition:\n  // starts at the beginning (\" ^ \") of anchorPosition and\n  // captures all of the characters (\" (.*?) \") until the\n  // first capital letter (\" [A-Z] \") is encountered\n  const [, primaryPosition] = anchorPosition.match(/^(.*?)[A-Z]/)!;\n  return anchorPositionToPopoverPositionMap[primaryPosition as AnchorPosition];\n}\n\nexport function getPopoverAlignFromAnchorPosition(\n  anchorPosition: PopoverAnchorPosition\n) {\n  // maps the gravity to the matching popover position\n  // e.g. \"upLeft\" -> \"left\", \"rightDown\" -> \"bottom\"\n\n  // extract the second positional word from anchorPosition:\n  // starts a capture group at the first capital letter\n  // and includes everything after it\n  const [, align] = anchorPosition.match(/([A-Z].*)/)!;\n\n  // this performs two tasks:\n  // 1. normalizes the align position by lowercasing it\n  // 2. `center` doesn't exist in the lookup map which converts it to `undefined` meaning no align\n  return anchorPositionToPopoverPositionMap[\n    align.toLowerCase() as AnchorPosition\n  ];\n}\n\nconst DEFAULT_POPOVER_STYLES = {\n  top: 50,\n  left: 50,\n};\n\nconst returnFocusConfig = { preventScroll: true };\nconst closingTransitionTime = 250; // TODO: DRY out var when converting to CSS-in-JS\n\nexport type Props = EuiPopoverProps & HTMLAttributes<HTMLDivElement>;\n\ninterface State {\n  prevProps: {\n    isOpen?: boolean;\n  };\n  suppressingPopover?: boolean;\n  isClosing: boolean;\n  isOpening: boolean;\n  popoverStyles: CSSProperties;\n  arrowStyles?: CSSProperties;\n  arrowPosition: EuiPopoverArrowPositions | null;\n  openPosition: any; // What should this be?\n  isOpenStable: boolean;\n}\n\ntype PropsWithDefaults = Props & {\n  anchorPosition: PopoverAnchorPosition;\n  hasArrow: boolean;\n  isOpen: boolean;\n  ownFocus: boolean;\n  panelPaddingSize: EuiPaddingSize;\n};\n\nexport class EuiPopover extends Component<Props, State> {\n  static defaultProps: Partial<PropsWithDefaults> = {\n    isOpen: false,\n    ownFocus: true,\n    anchorPosition: \"downCenter\",\n    panelPaddingSize: \"m\",\n    hasArrow: true,\n    display: \"inline-block\",\n  };\n\n  static getDerivedStateFromProps(\n    nextProps: Props,\n    prevState: State\n  ): Partial<State> | null {\n    if (prevState.prevProps.isOpen && !nextProps.isOpen) {\n      return {\n        prevProps: {\n          isOpen: nextProps.isOpen,\n        },\n        isClosing: true,\n        isOpening: false,\n      };\n    }\n\n    if (prevState.prevProps.isOpen !== nextProps.isOpen) {\n      return {\n        prevProps: {\n          isOpen: nextProps.isOpen,\n        },\n      };\n    }\n\n    return null;\n  }\n\n  private respositionTimeout: number | undefined;\n  private strandedFocusTimeout: number | undefined;\n  private closingTransitionTimeout: number | undefined;\n  private closingTransitionAnimationFrame: number | undefined;\n  private button: HTMLElement | null = null;\n  private panel: HTMLElement | null = null;\n  private descriptionId: string = htmlIdGenerator()();\n\n  constructor(props: Props) {\n    super(props);\n\n    this.state = {\n      prevProps: {\n        isOpen: props.isOpen,\n      },\n      suppressingPopover: props.isOpen, // only suppress if created with isOpen=true\n      isClosing: false,\n      isOpening: false,\n      popoverStyles: DEFAULT_POPOVER_STYLES,\n      arrowStyles: {},\n      arrowPosition: null,\n      openPosition: null, // once a stable position has been found, keep the contents on that side\n      isOpenStable: false, // wait for any initial opening transitions to finish before marking as stable\n    };\n  }\n\n  closePopover = () => {\n    if (this.props.isOpen) {\n      this.props.closePopover();\n    }\n  };\n\n  onEscapeKey = (event: Event) => {\n    if (this.props.isOpen) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.closePopover();\n      this.handleStrandedFocus();\n    }\n  };\n\n  handleStrandedFocus = () => {\n    this.strandedFocusTimeout = window.setTimeout(() => {\n      // If `returnFocus` failed and focus was stranded on the body,\n      // attempt to manually restore focus to the toggle button\n      if (document.activeElement === document.body) {\n        if (!this.button) return;\n\n        const focusableItems = focusable(this.button);\n        if (!focusableItems.length) return;\n\n        const toggleButton = focusableItems[0];\n        toggleButton.focus(returnFocusConfig);\n      }\n    }, closingTransitionTime);\n  };\n\n  onKeyDown = (event: KeyboardEvent) => {\n    if (event.key === cascadingMenuKeys.ESCAPE) {\n      this.onEscapeKey(event as unknown as Event);\n    }\n  };\n\n  onClickOutside = (event: Event) => {\n    // only close the popover if the event source isn't the anchor button\n    // otherwise, it is up to the anchor to toggle the popover's open status\n    if (this.button && this.button.contains(event.target as Node) === false) {\n      this.closePopover();\n    }\n  };\n\n  onOpenPopover = () => {\n    clearTimeout(this.strandedFocusTimeout);\n    clearTimeout(this.closingTransitionTimeout);\n    if (this.closingTransitionAnimationFrame) {\n      cancelAnimationFrame(this.closingTransitionAnimationFrame);\n    }\n    // We need to set this state a beat after the render takes place, so that the CSS\n    // transition can take effect.\n    this.closingTransitionAnimationFrame = window.requestAnimationFrame(() => {\n      this.setState({\n        isOpening: true,\n      });\n    });\n\n    // for each child element of `this.panel`, find any transition duration we should wait for before stabilizing\n    const { durationMatch, delayMatch } = Array.prototype.slice\n      .call(this.panel ? [this.panel, ...Array.from(this.panel.children)] : [])\n      .reduce(\n        ({ durationMatch, delayMatch }, element) => {\n          const transitionTimings = getTransitionTimings(element);\n\n          return {\n            durationMatch: Math.max(\n              durationMatch,\n              transitionTimings.durationMatch\n            ),\n            delayMatch: Math.max(delayMatch, transitionTimings.delayMatch),\n          };\n        },\n        { durationMatch: 0, delayMatch: 0 }\n      );\n\n    clearTimeout(this.respositionTimeout);\n    this.respositionTimeout = window.setTimeout(() => {\n      this.setState({ isOpenStable: true }, () => {\n        this.positionPopoverFixed();\n      });\n    }, durationMatch + delayMatch);\n  };\n\n  componentDidMount() {\n    if (this.state.suppressingPopover) {\n      // component was created with isOpen=true; now that it's mounted\n      // stop suppressing and start opening\n      // eslint-disable-next-line react/no-did-mount-set-state\n      this.setState({ suppressingPopover: false, isOpening: true }, () => {\n        this.onOpenPopover();\n      });\n    }\n\n    if (this.props.repositionOnScroll) {\n      window.addEventListener(\"scroll\", this.positionPopoverFixed, true);\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    // The popover is being opened.\n    if (!prevProps.isOpen && this.props.isOpen) {\n      this.onOpenPopover();\n    }\n\n    // update scroll listener\n    if (prevProps.repositionOnScroll !== this.props.repositionOnScroll) {\n      if (this.props.repositionOnScroll) {\n        window.addEventListener(\"scroll\", this.positionPopoverFixed, true);\n      } else {\n        window.removeEventListener(\"scroll\", this.positionPopoverFixed, true);\n      }\n    }\n\n    // The popover is being closed.\n    if (prevProps.isOpen && !this.props.isOpen) {\n      // If the user has just closed the popover, queue up the removal of the content after the\n      // transition is complete.\n      this.closingTransitionTimeout = window.setTimeout(() => {\n        this.setState({\n          isClosing: false,\n        });\n      }, closingTransitionTime);\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"scroll\", this.positionPopoverFixed, true);\n    clearTimeout(this.respositionTimeout);\n    clearTimeout(this.strandedFocusTimeout);\n    clearTimeout(this.closingTransitionTimeout);\n    cancelAnimationFrame(this.closingTransitionAnimationFrame!);\n  }\n\n  onMutation = (records: MutationRecord[]) => {\n    const waitDuration = getWaitDuration(records);\n    this.positionPopoverFixed();\n\n    performOnFrame(waitDuration, this.positionPopoverFixed);\n  };\n\n  positionPopover = (allowEnforcePosition: boolean) => {\n    if (this.button == null || this.panel == null) return;\n\n    const { anchorPosition } = this.props as PropsWithDefaults;\n\n    let position = getPopoverPositionFromAnchorPosition(anchorPosition);\n    let forcePosition = undefined;\n    if (\n      allowEnforcePosition &&\n      this.state.isOpenStable &&\n      this.state.openPosition != null\n    ) {\n      position = this.state.openPosition;\n      forcePosition = true;\n    }\n\n    const {\n      top,\n      left,\n      position: foundPosition,\n      arrow,\n      anchorBoundingBox,\n    } = findPopoverPosition({\n      container: this.props.container,\n      position,\n      forcePosition,\n      align: getPopoverAlignFromAnchorPosition(anchorPosition),\n      anchor: this.button,\n      popover: this.panel,\n      offset:\n        !this.props.attachToAnchor && this.props.hasArrow\n          ? 16 + (this.props.offset || 0)\n          : 8 + (this.props.offset || 0),\n      arrowConfig: {\n        arrowWidth: 24,\n        arrowBuffer: 10,\n      },\n      returnBoundingBox: this.props.attachToAnchor,\n      buffer: this.props.buffer,\n    });\n\n    // the popover's z-index must inherit from the button\n    // this keeps a button's popover under a flyout that would cover the button\n    // but a popover triggered inside a flyout will appear over that flyout\n    const { zIndex: zIndexProp } = this.props;\n    const zIndex =\n      zIndexProp == null\n        ? getElementZIndex(this.button, this.panel) + 2000\n        : zIndexProp;\n\n    const popoverStyles = {\n      ...this.props.panelStyle,\n      top,\n      left:\n        this.props.attachToAnchor && anchorBoundingBox\n          ? anchorBoundingBox.left\n          : left,\n      zIndex,\n    };\n\n    const willRenderArrow = !this.props.attachToAnchor && this.props.hasArrow;\n    const arrowStyles = willRenderArrow ? arrow : undefined;\n    const arrowPosition: EuiPopoverPosition = foundPosition;\n\n    this.props.onPositionChange && this.props.onPositionChange(arrowPosition);\n\n    this.setState({\n      popoverStyles,\n      arrowStyles,\n      arrowPosition,\n      openPosition: foundPosition,\n    });\n  };\n\n  positionPopoverFixed = () => {\n    this.positionPopover(true);\n  };\n\n  positionPopoverFluid = () => {\n    this.positionPopover(false);\n  };\n\n  panelRef = (node: HTMLElement | null) => {\n    this.panel = node;\n    this.props.panelRef && this.props.panelRef(node);\n\n    if (node == null) {\n      // panel has unmounted, restore the state defaults\n      this.setState({\n        popoverStyles: DEFAULT_POPOVER_STYLES,\n        arrowStyles: {},\n        arrowPosition: null,\n        openPosition: null,\n        isOpenStable: false,\n      });\n      window.removeEventListener(\"resize\", this.positionPopoverFluid);\n    } else {\n      // panel is coming into existence\n      this.positionPopoverFluid();\n      window.addEventListener(\"resize\", this.positionPopoverFluid);\n    }\n  };\n\n  buttonRef = (node: HTMLDivElement | null) => {\n    this.button = node;\n    this.props.buttonRef && this.props.buttonRef(node);\n  };\n\n  render() {\n    const {\n      anchorClassName,\n      anchorPosition,\n      button,\n      buttonRef,\n      insert,\n      isOpen,\n      ownFocus,\n      children,\n      className,\n      closePopover,\n      panelClassName,\n      panelPaddingSize,\n      panelProps,\n      panelRef,\n      panelStyle,\n      popoverScreenReaderText,\n      popoverRef,\n      hasArrow,\n      arrowChildren,\n      repositionOnScroll,\n      hasDragDrop,\n      zIndex,\n      attachToAnchor,\n      display,\n      offset,\n      onPositionChange,\n      onTrapDeactivation,\n      buffer,\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledBy,\n      container,\n      focusTrapProps,\n      initialFocus: initialFocusProp,\n      tabIndex: _tabIndexProp,\n      ...rest\n    } = this.props;\n    const tabIndexProp = panelProps?.tabIndex ?? _tabIndexProp;\n\n    const styles = euiPopoverStyles();\n    const popoverStyles = [styles.euiPopover, { display }];\n    const classes = classNames(\n      \"euiPopover\",\n      {\n        \"euiPopover-isOpen\": this.state.isOpening,\n      },\n      className\n    );\n\n    const anchorClasses = classNames(\"euiPopover__anchor\", anchorClassName);\n    const showArrow = hasArrow && !attachToAnchor;\n\n    let panel;\n\n    if (!this.state.suppressingPopover && (isOpen || this.state.isClosing)) {\n      let tabIndex = tabIndexProp;\n      let initialFocus = initialFocusProp;\n      let ariaDescribedby;\n      let ariaLive: HTMLAttributes<any>[\"aria-live\"];\n\n      const panelAriaModal = panelProps?.hasOwnProperty(\"aria-modal\")\n        ? panelProps[\"aria-modal\"]\n        : \"true\";\n      const panelRole = panelProps?.hasOwnProperty(\"role\")\n        ? panelProps.role\n        : \"dialog\";\n\n      if (ownFocus || panelAriaModal !== \"true\") {\n        tabIndex = tabIndexProp ?? 0;\n        ariaLive = \"off\";\n        if (!initialFocus) {\n          initialFocus = () => this.panel!;\n        }\n      } else {\n        ariaLive = \"assertive\";\n      }\n\n      let focusTrapScreenReaderText;\n      if (ownFocus || popoverScreenReaderText) {\n        ariaDescribedby = this.descriptionId;\n      }\n\n      const returnFocus = this.state.isOpenStable ? returnFocusConfig : false;\n\n      panel = (\n        <EuiPortal insert={insert}>\n          <EuiFocusTrap\n            clickOutsideDisables={true}\n            {...focusTrapProps}\n            returnFocus={returnFocus} // Ignore temporary state of indecisive focus\n            initialFocus={initialFocus}\n            onDeactivation={onTrapDeactivation}\n            onClickOutside={this.onClickOutside}\n            onEscapeKey={this.onEscapeKey}\n            disabled={\n              !ownFocus || !this.state.isOpenStable || this.state.isClosing\n            }\n          >\n            <EuiPopoverPanel\n              {...(panelProps as EuiPopoverPanelProps)}\n              panelRef={this.panelRef}\n              isOpen={this.state.isOpening}\n              position={this.state.arrowPosition}\n              isAttached={attachToAnchor}\n              className={classNames(panelClassName, panelProps?.className)}\n              hasDragDrop={hasDragDrop}\n              hasShadow={false}\n              paddingSize={panelPaddingSize}\n              tabIndex={tabIndex}\n              aria-live={ariaLive}\n              role={panelRole}\n              aria-label={ariaLabel}\n              aria-labelledby={ariaLabelledBy}\n              aria-modal={panelAriaModal}\n              aria-describedby={ariaDescribedby}\n              style={{\n                ...this.state.popoverStyles,\n                // Adding `will-change` to reduce risk of a blurry animation in Chrome 86+\n                willChange: !this.state.isOpenStable\n                  ? \"transform, opacity\"\n                  : undefined,\n              }}\n            >\n              {showArrow && this.state.arrowPosition && (\n                <EuiPopoverArrow\n                  position={this.state.arrowPosition}\n                  style={this.state.arrowStyles}\n                >\n                  {arrowChildren}\n                </EuiPopoverArrow>\n              )}\n              {focusTrapScreenReaderText}\n              <EuiMutationObserver\n                observerOptions={{\n                  attributes: true, // element attribute changes\n                  childList: true, // added/removed elements\n                  characterData: true, // text changes\n                  subtree: true, // watch all child elements\n                }}\n                onMutation={this.onMutation}\n              >\n                {(mutationRef) => <div ref={mutationRef}>{children}</div>}\n              </EuiMutationObserver>\n            </EuiPopoverPanel>\n          </EuiFocusTrap>\n        </EuiPortal>\n      );\n    }\n\n    // react-focus-on and related do not register outside click detection\n    // when disabled, so we still need to conditionally check for that ourselves\n    if (ownFocus) {\n      return (\n        <div css={popoverStyles} className={classes} ref={popoverRef} {...rest}>\n          <div css={{ display }} className={anchorClasses} ref={this.buttonRef}>\n            {button instanceof HTMLElement ? null : button}\n          </div>\n          {panel}\n        </div>\n      );\n    } else {\n      return (\n        <EuiOutsideClickDetector onOutsideClick={this.closePopover}>\n          <div\n            css={popoverStyles}\n            className={classes}\n            ref={popoverRef}\n            onKeyDown={this.onKeyDown}\n            {...rest}\n          >\n            <div\n              css={{ display }}\n              className={anchorClasses}\n              ref={this.buttonRef}\n            >\n              {button instanceof HTMLElement ? null : button}\n            </div>\n            {panel}\n          </div>\n        </EuiOutsideClickDetector>\n      );\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}