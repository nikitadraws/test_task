{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nexport const assertNever = x => {\n  throw new Error(`Unexpected value ${x}`);\n};\n\n// utility types:\n/**\n * XOR for some properties applied to a type\n * (XOR is one of these but not both or neither)\n *\n * Usage: OneOf<typeToExtend, one | but | not | multiple | of | these | are | required>\n *\n * To require aria-label or aria-labelledby but not both\n * Example: OneOf<Type, 'aria-label' | 'aria-labelledby'>\n */\n\n/**\n * Wraps Object.keys with proper typescript definition of the resulting array\n */\nexport function keysOf(obj) {\n  return Object.keys(obj);\n}\n\n/**\n * Like `keyof typeof`, but for getting values instead of keys\n * ValueOf<typeof {key1: 'value1', key2: 'value2'}>\n * Results in `'value1' | 'value2'`\n */","map":{"version":3,"names":["assertNever","x","Error","keysOf","obj","Object","keys"],"sources":["/Users/nikita/Downloads/super_date_picker/src/common.ts"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport {\n  AnchorHTMLAttributes,\n  ButtonHTMLAttributes,\n  ComponentProps,\n  Component,\n  FunctionComponent,\n  JSXElementConstructor,\n  MouseEventHandler,\n} from 'react';\nimport { Interpolation, Theme } from '@emotion/react';\n\nexport interface CommonProps {\n  className?: string;\n  'aria-label'?: string;\n  'data-test-subj'?: string;\n  css?: Interpolation<Theme>;\n}\n\nexport type NoArgCallback<T> = () => T;\n\nexport const assertNever = (x: never): never => {\n  throw new Error(`Unexpected value ${x}`);\n};\n\n// utility types:\n/**\n * XOR for some properties applied to a type\n * (XOR is one of these but not both or neither)\n *\n * Usage: OneOf<typeToExtend, one | but | not | multiple | of | these | are | required>\n *\n * To require aria-label or aria-labelledby but not both\n * Example: OneOf<Type, 'aria-label' | 'aria-labelledby'>\n */\nexport type OneOf<T, K extends keyof T> = Omit<T, K> &\n  { [k in K]: Pick<Required<T>, k> & { [k1 in Exclude<K, k>]?: never } }[K];\n\n/**\n * Wraps Object.keys with proper typescript definition of the resulting array\n */\nexport function keysOf<T extends {}, K extends keyof T>(obj: T): K[] {\n  return Object.keys(obj) as K[];\n}\n\n/**\n * Like `keyof typeof`, but for getting values instead of keys\n * ValueOf<typeof {key1: 'value1', key2: 'value2'}>\n * Results in `'value1' | 'value2'`\n */\nexport type ValueOf<T> = T[keyof T];\n\nexport type PropsOf<C> = C extends FunctionComponent<infer SFCProps>\n  ? SFCProps\n  : C extends FunctionComponent<infer FunctionProps>\n  ? FunctionProps\n  : C extends Component<infer ComponentProps>\n  ? ComponentProps\n  : never;\n\n// Returns the props of a given HTML element\nexport type PropsOfElement<\n  C extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>\n> = JSX.LibraryManagedAttributes<C, ComponentProps<C>>;\n\n// Utility methods for ApplyClassComponentDefaults\ntype ExtractDefaultProps<T> = T extends { defaultProps: infer D } ? D : never;\ntype ExtractProps<\n  C extends new (...args: any) => any,\n  IT = InstanceType<C>\n> = IT extends Component<infer P> ? P : never;\n\n/**\n * Because of how TypeScript's LibraryManagedAttributes is designed to handle defaultProps (https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#support-for-defaultprops-in-jsx)\n * we can't directly export the props definition as the defaulted values are not made optional,\n * because it isn't processed by LibraryManagedAttributes. To get around this, we:\n * - remove the props which have default values applied\n * - export (Props - Defaults) & Partial<Defaults>\n */\nexport type ApplyClassComponentDefaults<\n  C extends new (...args: any) => any,\n  D = ExtractDefaultProps<C>,\n  P = ExtractProps<C>\n> =\n  // definition of Props that are not defaulted\n  Omit<P, keyof D> &\n    // definition of Props, made optional, that are have keys in defaultProps\n    { [K in keyof D]?: K extends keyof P ? P[K] : never };\n\n/*\nhttps://github.com/Microsoft/TypeScript/issues/28339\nProblem: Pick and Omit do not distribute over union types, which manifests when\noptional values become required after a Pick or Omit operation. These\nDistributive forms correctly operate on union types, preserving optionality.\n */\ntype UnionKeys<T> = T extends any ? keyof T : never;\nexport type DistributivePick<T, K extends UnionKeys<T>> = T extends any\n  ? Pick<T, Extract<keyof T, K>>\n  : never;\nexport type DistributiveOmit<T, K extends UnionKeys<T>> = T extends any\n  ? Omit<T, Extract<keyof T, K>>\n  : never;\ntype RecursiveDistributiveOmit<T, K extends PropertyKey> = T extends any\n  ? T extends object\n    ? RecursiveOmit<T, K>\n    : T\n  : never;\nexport type RecursiveOmit<T, K extends PropertyKey> = Omit<\n  { [P in keyof T]: RecursiveDistributiveOmit<T[P], K> },\n  K\n>;\n\n/*\nTypeScript's discriminated unions are overly permissive: as long as one type of the union is satisfied\nthe other types are not validated against. For example:\n\ntype Foo = {\n  value: string,\n  foo: string\n};\ntype Bar = {\n  value: number,\n  bar: string\n}\nfunction what(x: Foo | Bar) {\n  return x.value;\n}\n\nAs you would expect -\n\nwhat({ value: 'asdf', foo: 'asdf' }); // fine\nwhat({ value: 5, foo: 'asdf' }); // error\nwhat({ value: 5, bar: 'asdf' }); // fine\nwhat({ value: 'asdf', bar: 'asdf' }); // error\n\nHowever, if Foo is satisfied then you can pass any value you want to Bar's unique properties:\nwhat({ value: 'asdf', foo: 'asdf', bar: false }) // works\n\nTypeScript is okay with this as a type guard would detect the object is Foo and prevent accessing `bar`.\nUnfortunately this prevents feedback to the user about potentially unintentional effects, for example:\n\nA common pattern in EUI is to render something as a div OR as a button, depending on if an onClick prop is passed.\npassing additional props down through `...rest`, which can be specified as\n\ntype Spanlike = HTMLAttributes<HTMLSpanElement>;\ntype Buttonlike = { onClick: MouseEventHandler<HTMLButtonElement> }; // onClick is the discriminant\nReact.FunctionComponent<Spanlike | Buttonlike>\n\nInternally, the component would have a type guard to check if props contains `onClick` and resolve to Buttonlike.\nExternally, however, you could use the component as\n\n<Component value=\"buzz\"/>\n\nand no error would occur as the Spanlike type is satisfied and the type guard would prevent accessing button attributes.\nThis prevents immediate feedback to the develop, and would actually lead to React warnings as the `value` prop would\nstill propagate down to the span's props, which is invalid. The following two utility types provide a solution for\ncreating exclusive unions:\n\nReact.FunctionComponent<ExclusiveUnion<Spanlike, Buttonlike>>\n */\n\n/**\n * Returns member keys in U not present in T set to never\n * T = { 'one', 'two', 'three' }\n * U = { 'three', 'four', 'five' }\n * returns { 'four': never, 'five': never }\n */\nexport type DisambiguateSet<T, U> = {\n  [P in Exclude<keyof T, keyof U>]?: never;\n};\n\n/**\n * Allow either T or U, preventing any additional keys of the other type from being present\n */\nexport type ExclusiveUnion<T, U> = T | U extends object // if there are any shared keys between T and U\n  ? (DisambiguateSet<T, U> & U) | (DisambiguateSet<U, T> & T) // otherwise the TS union is already unique\n  : T | U;\n\n/**\n * For components that conditionally render <button> or <a>\n * Convenience types for extending base props (T) and\n * element-specific props (P) with standard clickable properties\n *\n * These will likely be used together, along with `ExclusiveUnion`:\n *\n * type AnchorLike = PropsForAnchor<BaseProps>\n * type ButtonLike = PropsForButton<BaseProps>\n * type ComponentProps = ExclusiveUnion<AnchorLike, ButtonLike>\n * const Component: FunctionComponent<ComponentProps> ...\n */\nexport type PropsForAnchor<T, P = {}> = T & {\n  href?: string;\n  onClick?: MouseEventHandler<HTMLAnchorElement>;\n} & AnchorHTMLAttributes<HTMLAnchorElement> &\n  P;\n\nexport type PropsForButton<T, P = {}> = T & {\n  onClick?: MouseEventHandler<HTMLButtonElement>;\n} & ButtonHTMLAttributes<HTMLButtonElement> &\n  P;\n\n/**\n * Replaces all properties on any type as optional, includes nested types\n *\n * @example\n * ```ts\n * interface Person {\n *  name: string;\n *  age?: number;\n *  spouse: Person;\n *  children: Person[];\n * }\n * type PartialPerson = RecursivePartial<Person>;\n * // results in\n * interface PartialPerson {\n *  name?: string;\n *  age?: number;\n *  spouse?: RecursivePartial<Person>;\n *  children?: RecursivePartial<Person>[]\n * }\n * ```\n */\nexport type RecursivePartial<T> = {\n  [P in keyof T]?: T[P] extends NonAny[] // checks for nested any[]\n    ? T[P]\n    : T[P] extends readonly NonAny[] // checks for nested ReadonlyArray<any>\n    ? T[P]\n    : T[P] extends Array<infer U>\n    ? Array<RecursivePartial<U>>\n    : T[P] extends ReadonlyArray<infer U>\n    ? ReadonlyArray<RecursivePartial<U>>\n    : T[P] extends Set<infer V> // checks for Sets\n    ? Set<RecursivePartial<V>>\n    : T[P] extends Map<infer K, infer V> // checks for Maps\n    ? Map<K, RecursivePartial<V>>\n    : T[P] extends NonAny // checks for primitive values\n    ? T[P]\n    : RecursivePartial<T[P]>; // recurse for all non-array and non-primitive values\n};\ntype NonAny = number | boolean | string | symbol | null;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAsBA,OAAO,MAAMA,WAAW,GAAIC,CAAQ,IAAY;EAC9C,MAAM,IAAIC,KAAK,CAAE,oBAAmBD,CAAE,EAAC,CAAC;AAC1C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA,OAAO,SAASE,MAAM,CAAkCC,GAAM,EAAO;EACnE,OAAOC,MAAM,CAACC,IAAI,CAACF,GAAG,CAAC;AACzB;;AAEA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}