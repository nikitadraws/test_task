{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport dateMath from '@elastic/datemath';\nimport moment from 'moment';\nimport { get } from '../../services/objects';\nimport { isString } from '../../services/predicate';\nconst ROUND_DELIMETER = '/';\nexport const relativeUnitsFromLargestToSmallest = ['y', 'M', 'w', 'd', 'h', 'm', 's'];\nexport function parseRelativeParts(value) {\n  const matches = isString(value) && value.match(/now(([\\-\\+])([0-9]+)([smhdwMy])(\\/[smhdwMy])?)?/);\n  const operator = matches && matches[2];\n  const count = matches && matches[3];\n  const unit = matches && matches[4];\n  const roundBy = matches && matches[5];\n  if (count && unit) {\n    const isRounded = roundBy ? true : false;\n    const roundUnit = isRounded && roundBy ? roundBy.replace(ROUND_DELIMETER, '') : undefined;\n    return {\n      count: parseInt(count, 10),\n      unit: operator === '+' ? `${unit}+` : unit,\n      round: isRounded,\n      ...(roundUnit ? {\n        roundUnit\n      } : {})\n    };\n  }\n  const results = {\n    count: 0,\n    unit: 's',\n    round: false\n  };\n  const duration = moment.duration(moment().diff(dateMath.parse(value)));\n  let unitOp = '';\n  for (let i = 0; i < relativeUnitsFromLargestToSmallest.length; i++) {\n    const asRelative = duration.as(relativeUnitsFromLargestToSmallest[i]);\n    if (asRelative < 0) unitOp = '+';\n    if (Math.abs(asRelative) > 1) {\n      results.count = Math.round(Math.abs(asRelative));\n      results.unit = relativeUnitsFromLargestToSmallest[i] + unitOp;\n      results.round = false;\n      break;\n    }\n  }\n  return results;\n}\nexport const toRelativeStringFromParts = relativeParts => {\n  const count = get(relativeParts, 'count', 0);\n  const isRounded = get(relativeParts, 'round', false);\n  if (count === 0 && !isRounded) {\n    return 'now';\n  }\n  const matches = get(relativeParts, 'unit', 's').match(/([smhdwMy])(\\+)?/);\n  const unit = matches[1];\n  const operator = matches && matches[2] ? matches[2] : '-';\n  const round = isRounded ? `${ROUND_DELIMETER}${unit}` : '';\n  return `now${operator}${count}${unit}${round}`;\n};","map":{"version":3,"names":["dateMath","moment","get","isString","ROUND_DELIMETER","relativeUnitsFromLargestToSmallest","parseRelativeParts","value","matches","match","operator","count","unit","roundBy","isRounded","roundUnit","replace","undefined","parseInt","round","results","duration","diff","parse","unitOp","i","length","asRelative","as","Math","abs","toRelativeStringFromParts","relativeParts"],"sources":["/Users/nikita/Downloads/super_date_picker/src/date_picker/super_date_picker/relative_utils.ts"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport dateMath from '@elastic/datemath';\nimport moment from 'moment';\n\nimport { get } from '../../services/objects';\nimport { isString } from '../../services/predicate';\nimport { TimeUnitId, RelativeParts } from '../types';\n\nconst ROUND_DELIMETER = '/';\n\nexport const relativeUnitsFromLargestToSmallest: TimeUnitId[] = [\n  'y',\n  'M',\n  'w',\n  'd',\n  'h',\n  'm',\n  's',\n];\n\nexport function parseRelativeParts(value: string): RelativeParts {\n  const matches =\n    isString(value) &&\n    value.match(/now(([\\-\\+])([0-9]+)([smhdwMy])(\\/[smhdwMy])?)?/);\n\n  const operator = matches && matches[2];\n  const count = matches && matches[3];\n  const unit = matches && matches[4];\n  const roundBy = matches && matches[5];\n\n  if (count && unit) {\n    const isRounded = roundBy ? true : false;\n    const roundUnit =\n      isRounded && roundBy\n        ? (roundBy.replace(ROUND_DELIMETER, '') as TimeUnitId)\n        : undefined;\n    return {\n      count: parseInt(count, 10),\n      unit: operator === '+' ? `${unit}+` : unit,\n      round: isRounded,\n      ...(roundUnit ? { roundUnit } : {}),\n    };\n  }\n\n  const results = { count: 0, unit: 's', round: false };\n  const duration = moment.duration(moment().diff(dateMath.parse(value)));\n  let unitOp = '';\n  for (let i = 0; i < relativeUnitsFromLargestToSmallest.length; i++) {\n    const asRelative = duration.as(relativeUnitsFromLargestToSmallest[i]);\n    if (asRelative < 0) unitOp = '+';\n    if (Math.abs(asRelative) > 1) {\n      results.count = Math.round(Math.abs(asRelative));\n      results.unit = relativeUnitsFromLargestToSmallest[i] + unitOp;\n      results.round = false;\n      break;\n    }\n  }\n  return results;\n}\n\nexport const toRelativeStringFromParts = (relativeParts: RelativeParts) => {\n  const count = get(relativeParts, 'count', 0);\n  const isRounded = get(relativeParts, 'round', false);\n\n  if (count === 0 && !isRounded) {\n    return 'now';\n  }\n\n  const matches = get(relativeParts, 'unit', 's').match(/([smhdwMy])(\\+)?/);\n  const unit = matches[1];\n  const operator = matches && matches[2] ? matches[2] : '-';\n  const round = isRounded ? `${ROUND_DELIMETER}${unit}` : '';\n\n  return `now${operator}${count}${unit}${round}`;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}