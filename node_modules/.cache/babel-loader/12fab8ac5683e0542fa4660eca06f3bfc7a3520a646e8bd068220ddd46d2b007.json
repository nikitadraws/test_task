{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport chroma from 'chroma-js';\nexport const MID_COLOR_STOP = '#EBEFF5';\n\n/**\n * This function takes an array of colors and returns an array of interpolated\n * colors based on the number of steps/len needed for use in UI elements such as charts.\n * Derived from https://github.com/gka/palettes (Unlicensed)\n */\n\nexport function colorPalette(\n/**\n * The main color code or array of codes\n */\ncolors) {\n  let len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  let diverging = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let categorical = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let hexStart = colors.slice();\n  let hexEnd = [];\n  const even = len % 2 === 0;\n  const numColorsLeft = diverging ? Math.ceil(len / 2) + (even ? 1 : 0) : len;\n  const numColorsRight = diverging ? Math.ceil(len / 2) + (even ? 1 : 0) : 0;\n\n  // If only a single color is provided prepend the mid-point color\n  if (hexStart.length === 1) {\n    hexStart.unshift(MID_COLOR_STOP);\n  }\n\n  // If diverging, split the start array and duplicate the mid color\n  if (diverging) {\n    // If there's no midpoint, create one\n    if (hexStart.length < 3) {\n      hexStart[2] = hexStart[1];\n      hexStart[1] = MID_COLOR_STOP;\n    }\n    const numColorsHalf = Math.ceil(hexStart.length / 2);\n    const colorsLeft = hexStart.filter(function (_item, index) {\n      if (index < numColorsHalf) {\n        return true; // keep it\n      }\n\n      return;\n    });\n    const colorsRight = hexStart.reverse().filter(function (_item, index) {\n      if (index < numColorsHalf) {\n        return true; // keep it\n      }\n\n      return;\n    }).reverse();\n    hexStart = colorsLeft;\n    hexEnd = colorsRight;\n  }\n  function createSteps(colors, steps) {\n    if (!colors.length) {\n      return colors;\n    }\n    if (!categorical) {\n      return chroma.bezier(colors).scale().correctLightness().colors(steps);\n    } else {\n      return chroma.scale(colors).colors(steps);\n    }\n  }\n  const stepsLeft = createSteps(hexStart, numColorsLeft);\n  const stepsRight = createSteps(hexEnd, numColorsRight);\n  return (even && diverging ? stepsLeft.slice(0, stepsLeft.length - 1) : stepsLeft).concat(stepsRight.slice(1));\n}","map":{"version":3,"names":["chroma","MID_COLOR_STOP","colorPalette","colors","len","diverging","categorical","hexStart","slice","hexEnd","even","numColorsLeft","Math","ceil","numColorsRight","length","unshift","numColorsHalf","colorsLeft","filter","_item","index","colorsRight","reverse","createSteps","steps","bezier","scale","correctLightness","stepsLeft","stepsRight","concat"],"sources":["/Users/nikita/Downloads/super_date_picker/src/services/color/color_palette.ts"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport chroma from 'chroma-js';\n\nexport const MID_COLOR_STOP = '#EBEFF5';\n\n/**\n * This function takes an array of colors and returns an array of interpolated\n * colors based on the number of steps/len needed for use in UI elements such as charts.\n * Derived from https://github.com/gka/palettes (Unlicensed)\n */\n\nexport function colorPalette(\n  /**\n   * The main color code or array of codes\n   */\n  colors: string[],\n  /**\n   * The number of colors in the resulting array (default 10)\n   */\n  len: number = 10,\n  /**\n   * Forces color interpolation to be calculated separately for each half (default false)\n   */\n  diverging: boolean = false,\n  /**\n   * Uses a more static interpolation for non-continuous spectrums\n   */\n  categorical: boolean = false\n) {\n  let hexStart: string[] = colors.slice();\n  let hexEnd: string[] = [];\n\n  const even = len % 2 === 0;\n  const numColorsLeft = diverging ? Math.ceil(len / 2) + (even ? 1 : 0) : len;\n  const numColorsRight = diverging ? Math.ceil(len / 2) + (even ? 1 : 0) : 0;\n\n  // If only a single color is provided prepend the mid-point color\n  if (hexStart.length === 1) {\n    hexStart.unshift(MID_COLOR_STOP);\n  }\n\n  // If diverging, split the start array and duplicate the mid color\n  if (diverging) {\n    // If there's no midpoint, create one\n    if (hexStart.length < 3) {\n      hexStart[2] = hexStart[1];\n      hexStart[1] = MID_COLOR_STOP;\n    }\n\n    const numColorsHalf = Math.ceil(hexStart.length / 2);\n\n    const colorsLeft = hexStart.filter(function (_item, index) {\n      if (index < numColorsHalf) {\n        return true; // keep it\n      }\n      return\n    });\n    const colorsRight = hexStart\n      .reverse()\n      .filter(function (_item, index) {\n        if (index < numColorsHalf) {\n          return true; // keep it\n        }\n        return\n      })\n      .reverse();\n\n    hexStart = colorsLeft;\n    hexEnd = colorsRight;\n  }\n\n  function createSteps(colors: string[], steps: number) {\n    if (!colors.length) {\n      return colors;\n    }\n\n    if (!categorical) {\n      return chroma.bezier(colors).scale().correctLightness().colors(steps);\n    } else {\n      return chroma.scale(colors).colors(steps);\n    }\n  }\n\n  const stepsLeft = createSteps(hexStart, numColorsLeft);\n  const stepsRight = createSteps(hexEnd, numColorsRight);\n\n  return (even && diverging\n    ? stepsLeft.slice(0, stepsLeft.length - 1)\n    : stepsLeft\n  ).concat(stepsRight.slice(1));\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,MAAM,MAAM,WAAW;AAE9B,OAAO,MAAMC,cAAc,GAAG,SAAS;;AAEvC;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,YAAY;AAC1B;AACF;AACA;AACEC,MAAgB,EAahB;EAAA,IATAC,GAAW,uEAAG,EAAE;EAAA,IAIhBC,SAAkB,uEAAG,KAAK;EAAA,IAI1BC,WAAoB,uEAAG,KAAK;EAE5B,IAAIC,QAAkB,GAAGJ,MAAM,CAACK,KAAK,EAAE;EACvC,IAAIC,MAAgB,GAAG,EAAE;EAEzB,MAAMC,IAAI,GAAGN,GAAG,GAAG,CAAC,KAAK,CAAC;EAC1B,MAAMO,aAAa,GAAGN,SAAS,GAAGO,IAAI,CAACC,IAAI,CAACT,GAAG,GAAG,CAAC,CAAC,IAAIM,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGN,GAAG;EAC3E,MAAMU,cAAc,GAAGT,SAAS,GAAGO,IAAI,CAACC,IAAI,CAACT,GAAG,GAAG,CAAC,CAAC,IAAIM,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;;EAE1E;EACA,IAAIH,QAAQ,CAACQ,MAAM,KAAK,CAAC,EAAE;IACzBR,QAAQ,CAACS,OAAO,CAACf,cAAc,CAAC;EAClC;;EAEA;EACA,IAAII,SAAS,EAAE;IACb;IACA,IAAIE,QAAQ,CAACQ,MAAM,GAAG,CAAC,EAAE;MACvBR,QAAQ,CAAC,CAAC,CAAC,GAAGA,QAAQ,CAAC,CAAC,CAAC;MACzBA,QAAQ,CAAC,CAAC,CAAC,GAAGN,cAAc;IAC9B;IAEA,MAAMgB,aAAa,GAAGL,IAAI,CAACC,IAAI,CAACN,QAAQ,CAACQ,MAAM,GAAG,CAAC,CAAC;IAEpD,MAAMG,UAAU,GAAGX,QAAQ,CAACY,MAAM,CAAC,UAAUC,KAAK,EAAEC,KAAK,EAAE;MACzD,IAAIA,KAAK,GAAGJ,aAAa,EAAE;QACzB,OAAO,IAAI,CAAC,CAAC;MACf;;MACA;IACF,CAAC,CAAC;IACF,MAAMK,WAAW,GAAGf,QAAQ,CACzBgB,OAAO,EAAE,CACTJ,MAAM,CAAC,UAAUC,KAAK,EAAEC,KAAK,EAAE;MAC9B,IAAIA,KAAK,GAAGJ,aAAa,EAAE;QACzB,OAAO,IAAI,CAAC,CAAC;MACf;;MACA;IACF,CAAC,CAAC,CACDM,OAAO,EAAE;IAEZhB,QAAQ,GAAGW,UAAU;IACrBT,MAAM,GAAGa,WAAW;EACtB;EAEA,SAASE,WAAW,CAACrB,MAAgB,EAAEsB,KAAa,EAAE;IACpD,IAAI,CAACtB,MAAM,CAACY,MAAM,EAAE;MAClB,OAAOZ,MAAM;IACf;IAEA,IAAI,CAACG,WAAW,EAAE;MAChB,OAAON,MAAM,CAAC0B,MAAM,CAACvB,MAAM,CAAC,CAACwB,KAAK,EAAE,CAACC,gBAAgB,EAAE,CAACzB,MAAM,CAACsB,KAAK,CAAC;IACvE,CAAC,MAAM;MACL,OAAOzB,MAAM,CAAC2B,KAAK,CAACxB,MAAM,CAAC,CAACA,MAAM,CAACsB,KAAK,CAAC;IAC3C;EACF;EAEA,MAAMI,SAAS,GAAGL,WAAW,CAACjB,QAAQ,EAAEI,aAAa,CAAC;EACtD,MAAMmB,UAAU,GAAGN,WAAW,CAACf,MAAM,EAAEK,cAAc,CAAC;EAEtD,OAAO,CAACJ,IAAI,IAAIL,SAAS,GACrBwB,SAAS,CAACrB,KAAK,CAAC,CAAC,EAAEqB,SAAS,CAACd,MAAM,GAAG,CAAC,CAAC,GACxCc,SAAS,EACXE,MAAM,CAACD,UAAU,CAACtB,KAAK,CAAC,CAAC,CAAC,CAAC;AAC/B"},"metadata":{},"sourceType":"module","externalDependencies":[]}