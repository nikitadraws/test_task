{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport moment from 'moment';\nimport dateMath from '@elastic/datemath';\nimport { isString } from '../../../services/predicate';\nimport { DATE_MODES } from '../date_modes';\nimport { LAST, NEXT } from '../time_options';\nimport { relativeUnitsFromLargestToSmallest } from '../relative_utils';\nconst isNow = value => value === DATE_MODES.NOW;\n\n/**\n * This function returns time value, time unit and time tense for a given time string.\n *\n * For example: for `now-40m` it will parse output as time value to `40` time unit to `m` and time unit to `last`.\n *\n * If given a datetime string it will return a default value.\n *\n * If the given string is in the format such as `now/d` it will parse the string to moment object and find the time value, time unit and time tense using moment\n *\n * This function accepts two strings start and end time. I the start value is now then it uses the end value to parse.\n */\nexport const parseTimeParts = (start, end) => {\n  const results = {\n    timeTense: LAST,\n    timeUnits: 'm',\n    timeValue: 15\n  };\n  const value = isNow(start) ? end : start;\n  const matches = isString(value) && value.match(/now(([-+])(\\d+)([smhdwMy])(\\/[smhdwMy])?)?/);\n  if (!matches) {\n    return results;\n  }\n  const operator = matches[2];\n  const matchedTimeValue = matches[3];\n  const timeUnits = matches[4];\n  if (matchedTimeValue && timeUnits && operator) {\n    return {\n      timeTense: operator === '+' ? NEXT : LAST,\n      timeUnits,\n      timeValue: parseInt(matchedTimeValue, 10)\n    };\n  }\n  const duration = moment.duration(moment().diff(dateMath.parse(value)));\n  let unitOp = '';\n  for (let i = 0; i < relativeUnitsFromLargestToSmallest.length; i++) {\n    const as = duration.as(relativeUnitsFromLargestToSmallest[i]);\n    if (as < 0) {\n      unitOp = '+';\n    }\n    if (Math.abs(as) > 1) {\n      return {\n        timeValue: Math.round(Math.abs(as)),\n        timeUnits: relativeUnitsFromLargestToSmallest[i],\n        timeTense: unitOp === '+' ? NEXT : LAST\n      };\n    }\n  }\n  return results;\n};","map":{"version":3,"names":["moment","dateMath","isString","DATE_MODES","LAST","NEXT","relativeUnitsFromLargestToSmallest","isNow","value","NOW","parseTimeParts","start","end","results","timeTense","timeUnits","timeValue","matches","match","operator","matchedTimeValue","parseInt","duration","diff","parse","unitOp","i","length","as","Math","abs","round"],"sources":["/Users/nikita/Downloads/super_date_picker/src/date_picker/super_date_picker/quick_select_popover/quick_select_utils.ts"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport moment from 'moment';\nimport dateMath from '@elastic/datemath';\nimport { isString } from '../../../services/predicate';\nimport { DATE_MODES } from '../date_modes';\nimport { QuickSelect, TimeUnitId } from '../../types';\nimport { LAST, NEXT } from '../time_options';\nimport { relativeUnitsFromLargestToSmallest } from '../relative_utils';\n\nconst isNow = (value: string) => value === DATE_MODES.NOW;\n\n/**\n * This function returns time value, time unit and time tense for a given time string.\n *\n * For example: for `now-40m` it will parse output as time value to `40` time unit to `m` and time unit to `last`.\n *\n * If given a datetime string it will return a default value.\n *\n * If the given string is in the format such as `now/d` it will parse the string to moment object and find the time value, time unit and time tense using moment\n *\n * This function accepts two strings start and end time. I the start value is now then it uses the end value to parse.\n */\nexport const parseTimeParts = (start: string, end: string): QuickSelect => {\n  const results: QuickSelect = {\n    timeTense: LAST,\n    timeUnits: 'm',\n    timeValue: 15,\n  };\n\n  const value = isNow(start) ? end : start;\n\n  const matches =\n    isString(value) &&\n    value.match(/now(([-+])(\\d+)([smhdwMy])(\\/[smhdwMy])?)?/);\n\n  if (!matches) {\n    return results;\n  }\n\n  const operator = matches[2];\n  const matchedTimeValue = matches[3];\n  const timeUnits = matches[4] as TimeUnitId;\n\n  if (matchedTimeValue && timeUnits && operator) {\n    return {\n      timeTense: operator === '+' ? NEXT : LAST,\n      timeUnits,\n      timeValue: parseInt(matchedTimeValue, 10),\n    };\n  }\n\n  const duration = moment.duration(moment().diff(dateMath.parse(value)));\n  let unitOp = '';\n  for (let i = 0; i < relativeUnitsFromLargestToSmallest.length; i++) {\n    const as = duration.as(relativeUnitsFromLargestToSmallest[i]);\n    if (as < 0) {\n      unitOp = '+';\n    }\n    if (Math.abs(as) > 1) {\n      return {\n        timeValue: Math.round(Math.abs(as)),\n        timeUnits: relativeUnitsFromLargestToSmallest[i],\n        timeTense: unitOp === '+' ? NEXT : LAST,\n      };\n    }\n  }\n\n  return results;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,MAAM,MAAM,QAAQ;AAC3B,OAAOC,QAAQ,MAAM,mBAAmB;AACxC,SAASC,QAAQ,QAAQ,6BAA6B;AACtD,SAASC,UAAU,QAAQ,eAAe;AAE1C,SAASC,IAAI,EAAEC,IAAI,QAAQ,iBAAiB;AAC5C,SAASC,kCAAkC,QAAQ,mBAAmB;AAEtE,MAAMC,KAAK,GAAIC,KAAa,IAAKA,KAAK,KAAKL,UAAU,CAACM,GAAG;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAG,CAACC,KAAa,EAAEC,GAAW,KAAkB;EACzE,MAAMC,OAAoB,GAAG;IAC3BC,SAAS,EAAEV,IAAI;IACfW,SAAS,EAAE,GAAG;IACdC,SAAS,EAAE;EACb,CAAC;EAED,MAAMR,KAAK,GAAGD,KAAK,CAACI,KAAK,CAAC,GAAGC,GAAG,GAAGD,KAAK;EAExC,MAAMM,OAAO,GACXf,QAAQ,CAACM,KAAK,CAAC,IACfA,KAAK,CAACU,KAAK,CAAC,4CAA4C,CAAC;EAE3D,IAAI,CAACD,OAAO,EAAE;IACZ,OAAOJ,OAAO;EAChB;EAEA,MAAMM,QAAQ,GAAGF,OAAO,CAAC,CAAC,CAAC;EAC3B,MAAMG,gBAAgB,GAAGH,OAAO,CAAC,CAAC,CAAC;EACnC,MAAMF,SAAS,GAAGE,OAAO,CAAC,CAAC,CAAe;EAE1C,IAAIG,gBAAgB,IAAIL,SAAS,IAAII,QAAQ,EAAE;IAC7C,OAAO;MACLL,SAAS,EAAEK,QAAQ,KAAK,GAAG,GAAGd,IAAI,GAAGD,IAAI;MACzCW,SAAS;MACTC,SAAS,EAAEK,QAAQ,CAACD,gBAAgB,EAAE,EAAE;IAC1C,CAAC;EACH;EAEA,MAAME,QAAQ,GAAGtB,MAAM,CAACsB,QAAQ,CAACtB,MAAM,EAAE,CAACuB,IAAI,CAACtB,QAAQ,CAACuB,KAAK,CAAChB,KAAK,CAAC,CAAC,CAAC;EACtE,IAAIiB,MAAM,GAAG,EAAE;EACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,kCAAkC,CAACqB,MAAM,EAAED,CAAC,EAAE,EAAE;IAClE,MAAME,EAAE,GAAGN,QAAQ,CAACM,EAAE,CAACtB,kCAAkC,CAACoB,CAAC,CAAC,CAAC;IAC7D,IAAIE,EAAE,GAAG,CAAC,EAAE;MACVH,MAAM,GAAG,GAAG;IACd;IACA,IAAII,IAAI,CAACC,GAAG,CAACF,EAAE,CAAC,GAAG,CAAC,EAAE;MACpB,OAAO;QACLZ,SAAS,EAAEa,IAAI,CAACE,KAAK,CAACF,IAAI,CAACC,GAAG,CAACF,EAAE,CAAC,CAAC;QACnCb,SAAS,EAAET,kCAAkC,CAACoB,CAAC,CAAC;QAChDZ,SAAS,EAAEW,MAAM,KAAK,GAAG,GAAGpB,IAAI,GAAGD;MACrC,CAAC;IACH;EACF;EAEA,OAAOS,OAAO;AAChB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}