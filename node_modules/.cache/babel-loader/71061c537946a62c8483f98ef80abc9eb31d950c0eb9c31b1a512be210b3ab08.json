{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nconst getVisibleArea = (bounds, windowWidth, windowHeight) => {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = bounds;\n  // This is a common algorithm for finding the intersected area among two rectangles.\n  const dx = Math.min(left + width, windowWidth) - Math.max(left, 0);\n  const dy = Math.min(top + height, windowHeight) - Math.max(top, 0);\n  return dx * dy;\n};\nconst positionAtTop = (anchorBounds, width, height, buffer) => {\n  const widthDifference = width - anchorBounds.width;\n  const left = anchorBounds.left - widthDifference * 0.5;\n  const top = anchorBounds.top - height - buffer;\n  return {\n    left,\n    top,\n    width,\n    height\n  };\n};\nconst positionAtRight = (anchorBounds, width, height, buffer) => {\n  const left = anchorBounds.right + buffer;\n  const heightDifference = height - anchorBounds.height;\n  const top = anchorBounds.top - heightDifference * 0.5;\n  return {\n    left,\n    top,\n    width,\n    height\n  };\n};\nconst positionAtBottom = (anchorBounds, width, height, buffer) => {\n  const widthDifference = width - anchorBounds.width;\n  const left = anchorBounds.left - widthDifference * 0.5;\n  const top = anchorBounds.bottom + buffer;\n  return {\n    left,\n    top,\n    width,\n    height\n  };\n};\nconst positionAtLeft = (anchorBounds, width, height, buffer) => {\n  const left = anchorBounds.left - width - buffer;\n  const heightDifference = height - anchorBounds.height;\n  const top = anchorBounds.top - heightDifference * 0.5;\n  return {\n    left,\n    top,\n    width,\n    height\n  };\n};\nconst positionToPositionerMap = {\n  top: positionAtTop,\n  right: positionAtRight,\n  bottom: positionAtBottom,\n  left: positionAtLeft\n};\n\n/**\n * Determine the best position for a popover that avoids clipping by the window view port.\n *\n * @param {Object} anchorBounds - getBoundingClientRect() of the node the popover is tethered to (e.g. a button).\n * @param {Object} popoverBounds - getBoundingClientRect() of the popover node (e.g. the tooltip).\n * @param {string} requestedPosition - Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param {number} buffer - The space between the wrapper and the popover. Also the minimum space between the\n * popover and the window.\n * @param {Array} positions - List of acceptable positions. Defaults to [\"top\", \"right\", \"bottom\", \"left\"].\n *\n * @returns {Object} With properties position (one of [\"top\", \"right\", \"bottom\", \"left\"]), left, top, width, and height.\n */\nexport function calculatePopoverPosition(anchorBounds, popoverBounds, requestedPosition) {\n  let buffer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 16;\n  let positions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['top', 'right', 'bottom', 'left'];\n  if (typeof buffer !== 'number') {\n    throw new Error(`calculatePopoverPosition received a buffer argument of ${buffer}' but expected a number`);\n  }\n  const windowWidth = window.innerWidth;\n  const windowHeight = window.innerHeight;\n  const {\n    width: popoverWidth,\n    height: popoverHeight\n  } = popoverBounds;\n  const positionToBoundsMap = {};\n  const positionToVisibleAreaMap = {};\n  positions.forEach(position => {\n    const bounds = positionToPositionerMap[position](anchorBounds, popoverWidth, popoverHeight, buffer);\n    positionToBoundsMap[position] = bounds;\n\n    // Calculate how much area of the popover is visible at each position.\n    positionToVisibleAreaMap[position] = getVisibleArea(bounds, windowWidth, windowHeight);\n  });\n\n  // If the requested position clips the popover, find the position which clips the popover the least.\n  // Default to use the requested position.\n  const calculatedPopoverPosition = positions.reduce((mostVisiblePosition, position) => {\n    if (positionToVisibleAreaMap[position] > positionToVisibleAreaMap[mostVisiblePosition]) {\n      return position;\n    }\n    return mostVisiblePosition;\n  }, requestedPosition);\n  return {\n    position: calculatedPopoverPosition,\n    ...positionToBoundsMap[calculatedPopoverPosition]\n  };\n}","map":{"version":3,"names":["getVisibleArea","bounds","windowWidth","windowHeight","left","top","width","height","dx","Math","min","max","dy","positionAtTop","anchorBounds","buffer","widthDifference","positionAtRight","right","heightDifference","positionAtBottom","bottom","positionAtLeft","positionToPositionerMap","calculatePopoverPosition","popoverBounds","requestedPosition","positions","Error","window","innerWidth","innerHeight","popoverWidth","popoverHeight","positionToBoundsMap","positionToVisibleAreaMap","forEach","position","calculatedPopoverPosition","reduce","mostVisiblePosition"],"sources":["/Users/nikita/Downloads/super_date_picker/src/services/popover/calculate_popover_position.ts"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { EuiPopoverPosition } from './types';\n\ninterface EuiPopoverBoundingBox {\n  top: number;\n  left: number;\n  width: number;\n  height: number;\n}\n\ninterface EuiPopoverAnchorRect extends EuiPopoverBoundingBox {\n  right: number;\n  bottom: number;\n}\n\ninterface EuiPopoverDimensions {\n  width: number;\n  height: number;\n}\n\ninterface EuiPopoverPositionedBox extends EuiPopoverBoundingBox {\n  position: EuiPopoverPosition;\n}\n\nconst getVisibleArea = (\n  bounds: EuiPopoverBoundingBox,\n  windowWidth: number,\n  windowHeight: number\n): number => {\n  const { left, top, width, height } = bounds;\n  // This is a common algorithm for finding the intersected area among two rectangles.\n  const dx = Math.min(left + width, windowWidth) - Math.max(left, 0);\n  const dy = Math.min(top + height, windowHeight) - Math.max(top, 0);\n  return dx * dy;\n};\n\ntype Positioner = (\n  bounds: EuiPopoverAnchorRect,\n  width: number,\n  height: number,\n  buffer: number\n) => EuiPopoverBoundingBox;\n\nconst positionAtTop: Positioner = (anchorBounds, width, height, buffer) => {\n  const widthDifference = width - anchorBounds.width;\n  const left = anchorBounds.left - widthDifference * 0.5;\n  const top = anchorBounds.top - height - buffer;\n  return { left, top, width, height };\n};\n\nconst positionAtRight: Positioner = (anchorBounds, width, height, buffer) => {\n  const left = anchorBounds.right + buffer;\n  const heightDifference = height - anchorBounds.height;\n  const top = anchorBounds.top - heightDifference * 0.5;\n  return { left, top, width, height };\n};\n\nconst positionAtBottom: Positioner = (anchorBounds, width, height, buffer) => {\n  const widthDifference = width - anchorBounds.width;\n  const left = anchorBounds.left - widthDifference * 0.5;\n  const top = anchorBounds.bottom + buffer;\n  return { left, top, width, height };\n};\n\nconst positionAtLeft: Positioner = (anchorBounds, width, height, buffer) => {\n  const left = anchorBounds.left - width - buffer;\n  const heightDifference = height - anchorBounds.height;\n  const top = anchorBounds.top - heightDifference * 0.5;\n  return { left, top, width, height };\n};\n\nconst positionToPositionerMap: { [position: string]: Positioner } = {\n  top: positionAtTop,\n  right: positionAtRight,\n  bottom: positionAtBottom,\n  left: positionAtLeft,\n};\n\n/**\n * Determine the best position for a popover that avoids clipping by the window view port.\n *\n * @param {Object} anchorBounds - getBoundingClientRect() of the node the popover is tethered to (e.g. a button).\n * @param {Object} popoverBounds - getBoundingClientRect() of the popover node (e.g. the tooltip).\n * @param {string} requestedPosition - Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param {number} buffer - The space between the wrapper and the popover. Also the minimum space between the\n * popover and the window.\n * @param {Array} positions - List of acceptable positions. Defaults to [\"top\", \"right\", \"bottom\", \"left\"].\n *\n * @returns {Object} With properties position (one of [\"top\", \"right\", \"bottom\", \"left\"]), left, top, width, and height.\n */\nexport function calculatePopoverPosition(\n  anchorBounds: EuiPopoverAnchorRect,\n  popoverBounds: EuiPopoverDimensions,\n  requestedPosition: EuiPopoverPosition,\n  buffer: number = 16,\n  positions: EuiPopoverPosition[] = ['top', 'right', 'bottom', 'left']\n): EuiPopoverPositionedBox {\n  if (typeof buffer !== 'number') {\n    throw new Error(\n      `calculatePopoverPosition received a buffer argument of ${buffer}' but expected a number`\n    );\n  }\n\n  const windowWidth = window.innerWidth;\n  const windowHeight = window.innerHeight;\n  const { width: popoverWidth, height: popoverHeight } = popoverBounds;\n\n  const positionToBoundsMap: { [position: string]: EuiPopoverBoundingBox } = {};\n  const positionToVisibleAreaMap: { [positon: string]: number } = {};\n\n  positions.forEach((position) => {\n    const bounds = positionToPositionerMap[position](\n      anchorBounds,\n      popoverWidth,\n      popoverHeight,\n      buffer\n    );\n    positionToBoundsMap[position] = bounds;\n\n    // Calculate how much area of the popover is visible at each position.\n    positionToVisibleAreaMap[position] = getVisibleArea(\n      bounds,\n      windowWidth,\n      windowHeight\n    );\n  });\n\n  // If the requested position clips the popover, find the position which clips the popover the least.\n  // Default to use the requested position.\n  const calculatedPopoverPosition = positions.reduce(\n    (mostVisiblePosition, position) => {\n      if (\n        positionToVisibleAreaMap[position] >\n        positionToVisibleAreaMap[mostVisiblePosition]\n      ) {\n        return position;\n      }\n      return mostVisiblePosition;\n    },\n    requestedPosition\n  );\n\n  return {\n    position: calculatedPopoverPosition,\n    ...positionToBoundsMap[calculatedPopoverPosition],\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}