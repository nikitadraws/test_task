{"ast":null,"code":"var _jsxFileName = \"/Users/nikita/Downloads/super_date_picker/src/i18n/i18n.tsx\",\n  _s = $RefreshSig$();\n/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { Fragment, useContext } from \"react\";\nimport { EuiI18nConsumer } from \"../context\";\nimport { I18nContext } from \"../context/context\";\nimport { processStringToChildren } from \"./i18n_util\";\nimport React from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction errorOnMissingValues(token) {\n  throw new Error(`I18n mapping for token \"${token}\" is a formatting function but no values were provided.`);\n}\nfunction lookupToken(options) {\n  const {\n    token,\n    i18nMapping,\n    valueDefault,\n    i18nMappingFunc,\n    values,\n    render\n  } = options;\n  let renderable = i18nMapping && i18nMapping[token] || valueDefault;\n  if (typeof renderable === \"function\") {\n    if (values === undefined) {\n      return errorOnMissingValues(token);\n    }\n    // @ts-ignore TypeScript complains that `DEFAULT` doesn't have a call signature but we verified `renderable` is a function\n    const rendered = renderable(values);\n    return i18nMappingFunc && typeof rendered === \"string\" ? i18nMappingFunc(rendered) : rendered;\n  } else if (values === undefined || typeof renderable !== \"string\") {\n    if (i18nMappingFunc && typeof valueDefault === \"string\") {\n      renderable = i18nMappingFunc(valueDefault);\n    }\n    // there's a hole in the typings here as there is no guarantee that i18nMappingFunc\n    // returned the same type of the default value, but we need to keep that assumption\n    return renderable;\n  }\n  const children = processStringToChildren(renderable, values, i18nMappingFunc);\n  if (typeof children === \"string\") {\n    // likewise, `processStringToChildren` returns a string or ReactChild[] depending on\n    // the type of `values`, so we will make the assumption that the default value is correct.\n    return children;\n  }\n  const Component = render ? render(children) : () => /*#__PURE__*/_jsxDEV(Fragment, {\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 83,\n    columnNumber: 13\n  }, this);\n\n  // same reasons as above, we can't promise the transforms match the default's type\n  return /*#__PURE__*/React.createElement(Component, values);\n}\nfunction isI18nTokensShape(x) {\n  return x.tokens != null;\n}\n\n// Must use the generics <T extends {}>\n// If instead typed with React.FunctionComponent there isn't feedback given back to the dev\n// when using a `values` object with a renderer callback.\nconst EuiI18n = props => /*#__PURE__*/_jsxDEV(EuiI18nConsumer, {\n  children: i18nConfig => {\n    const {\n      mapping,\n      mappingFunc,\n      render\n    } = i18nConfig;\n    if (isI18nTokensShape(props)) {\n      return props.children(props.tokens.map((token, idx) => lookupToken({\n        token,\n        i18nMapping: mapping,\n        i18nMappingFunc: mappingFunc,\n        valueDefault: props.defaults[idx],\n        render\n      })));\n    }\n    const tokenValue = lookupToken({\n      token: props.token,\n      i18nMapping: mapping,\n      valueDefault: props.default,\n      i18nMappingFunc: mappingFunc,\n      values: props.values,\n      render\n    });\n    if (props.children) {\n      return props.children(tokenValue);\n    } else {\n      return tokenValue;\n    }\n  }\n}, void 0, false, {\n  fileName: _jsxFileName,\n  lineNumber: 126,\n  columnNumber: 3\n}, this);\n\n// A single default could be a string, react child, or render function\n_c = EuiI18n;\nfunction useEuiI18n() {\n  _s();\n  const i18nConfig = useContext(I18nContext);\n  const {\n    mapping,\n    mappingFunc,\n    render\n  } = i18nConfig;\n  for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n    props[_key] = arguments[_key];\n  }\n  if (typeof props[0] === \"string\") {\n    const [token, defaultValue, values] = props;\n    return lookupToken({\n      token,\n      i18nMapping: mapping,\n      valueDefault: defaultValue,\n      i18nMappingFunc: mappingFunc,\n      values,\n      render\n    });\n  } else {\n    const [tokens, defaultValues] = props;\n    return tokens.map((token, idx) => lookupToken({\n      token,\n      i18nMapping: mapping,\n      valueDefault: defaultValues[idx],\n      i18nMappingFunc: mappingFunc,\n      render\n    }));\n  }\n}\n_s(useEuiI18n, \"4NOazizduy/HjbLj4JBDd2JCL8s=\");\nexport { EuiI18n, useEuiI18n };\nvar _c;\n$RefreshReg$(_c, \"EuiI18n\");","map":{"version":3,"names":["Fragment","useContext","EuiI18nConsumer","I18nContext","processStringToChildren","React","errorOnMissingValues","token","Error","lookupToken","options","i18nMapping","valueDefault","i18nMappingFunc","values","render","renderable","undefined","rendered","children","Component","createElement","isI18nTokensShape","x","tokens","EuiI18n","props","i18nConfig","mapping","mappingFunc","map","idx","defaults","tokenValue","default","useEuiI18n","defaultValue","defaultValues"],"sources":["/Users/nikita/Downloads/super_date_picker/src/i18n/i18n.tsx"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport {\n  Fragment,\n  ReactChild,\n  FunctionComponent,\n  useContext,\n  ReactElement,\n} from \"react\";\nimport { EuiI18nConsumer } from \"../context\";\nimport { ExclusiveUnion } from \"../common\";\nimport {\n  I18nContext,\n  I18nShape,\n  Renderable,\n  RenderableValues,\n} from \"../context/context\";\nimport { processStringToChildren } from \"./i18n_util\";\nimport React from \"react\";\n\nfunction errorOnMissingValues(token: string): never {\n  throw new Error(\n    `I18n mapping for token \"${token}\" is a formatting function but no values were provided.`\n  );\n}\n\ninterface lookupTokenOptions<\n  T extends RenderableValues,\n  DEFAULT extends Renderable<T>\n> {\n  token: string;\n  i18nMapping: I18nShape[\"mapping\"];\n  valueDefault: DEFAULT;\n  i18nMappingFunc?: (token: string) => string;\n  values?: I18nTokenShape<T, DEFAULT>[\"values\"];\n  render?: I18nShape[\"render\"];\n}\n\nfunction lookupToken<\n  T extends RenderableValues,\n  DEFAULT extends Renderable<T>,\n  RESOLVED extends ResolvedType<DEFAULT>\n>(options: lookupTokenOptions<T, DEFAULT>): RESOLVED {\n  const { token, i18nMapping, valueDefault, i18nMappingFunc, values, render } =\n    options;\n  let renderable = (i18nMapping && i18nMapping[token]) || valueDefault;\n\n  if (typeof renderable === \"function\") {\n    if (values === undefined) {\n      return errorOnMissingValues(token);\n    }\n    // @ts-ignore TypeScript complains that `DEFAULT` doesn't have a call signature but we verified `renderable` is a function\n    const rendered = renderable(values);\n    return (\n      i18nMappingFunc && typeof rendered === \"string\"\n        ? i18nMappingFunc(rendered)\n        : rendered\n    ) as RESOLVED;\n  } else if (values === undefined || typeof renderable !== \"string\") {\n    if (i18nMappingFunc && typeof valueDefault === \"string\") {\n      renderable = i18nMappingFunc(valueDefault);\n    }\n    // there's a hole in the typings here as there is no guarantee that i18nMappingFunc\n    // returned the same type of the default value, but we need to keep that assumption\n    return renderable as RESOLVED;\n  }\n\n  const children = processStringToChildren(renderable, values, i18nMappingFunc);\n  if (typeof children === \"string\") {\n    // likewise, `processStringToChildren` returns a string or ReactChild[] depending on\n    // the type of `values`, so we will make the assumption that the default value is correct.\n    return children as RESOLVED;\n  }\n\n  const Component: FunctionComponent<any> = render\n    ? render(children)\n    : () => <Fragment>{children}</Fragment>;\n\n  // same reasons as above, we can't promise the transforms match the default's type\n  return React.createElement(Component, values) as RESOLVED;\n}\n\ntype ResolvedType<T> = T extends (...args: any[]) => any ? ReturnType<T> : T;\n\ninterface I18nTokenShape<T, DEFAULT extends Renderable<T>> {\n  token: string;\n  default: DEFAULT;\n  children?: (x: ResolvedType<DEFAULT>) => ReactChild;\n  values?: T;\n}\n\ninterface I18nTokensShape<T extends any[]> {\n  tokens: string[];\n  defaults: T;\n  children: (x: Array<T[number]>) => ReactChild;\n}\n\nexport type EuiI18nProps<\n  T,\n  DEFAULT extends Renderable<T>,\n  DEFAULTS extends any[]\n> = ExclusiveUnion<I18nTokenShape<T, DEFAULT>, I18nTokensShape<DEFAULTS>>;\n\nfunction isI18nTokensShape<T extends any[]>(\n  x: EuiI18nProps<any, any, T>\n): x is I18nTokensShape<T> {\n  return x.tokens != null;\n}\n\n// Must use the generics <T extends {}>\n// If instead typed with React.FunctionComponent there isn't feedback given back to the dev\n// when using a `values` object with a renderer callback.\nconst EuiI18n = <\n  T extends {},\n  DEFAULT extends Renderable<T>,\n  DEFAULTS extends any[]\n>(\n  props: EuiI18nProps<T, DEFAULT, DEFAULTS>\n) => (\n  <EuiI18nConsumer>\n    {(i18nConfig) => {\n      const { mapping, mappingFunc, render } = i18nConfig;\n\n      if (isI18nTokensShape(props)) {\n        return props.children(\n          props.tokens.map((token, idx) =>\n            lookupToken({\n              token,\n              i18nMapping: mapping,\n              i18nMappingFunc: mappingFunc,\n              valueDefault: props.defaults[idx],\n              render,\n            })\n          )\n        );\n      }\n\n      const tokenValue = lookupToken({\n        token: props.token,\n        i18nMapping: mapping,\n        valueDefault: props.default,\n        i18nMappingFunc: mappingFunc,\n        values: props.values,\n        render,\n      });\n      if (props.children) {\n        return props.children(tokenValue);\n      } else {\n        return tokenValue;\n      }\n    }}\n  </EuiI18nConsumer>\n);\n\n// A single default could be a string, react child, or render function\ntype DefaultRenderType<T, K extends Renderable<T>> = K extends ReactChild\n  ? K\n  : K extends () => infer RetValue\n  ? RetValue\n  : never;\n\n// An array with multiple defaults can only be an array of strings or elements\ntype DefaultsRenderType<K extends Array<string | ReactElement>> =\n  K extends Array<infer Item> ? Item : never;\n\nfunction useEuiI18n<T extends {}, DEFAULT extends Renderable<T>>(\n  token: string,\n  defaultValue: DEFAULT,\n  values?: T\n): DefaultRenderType<T, DEFAULT>;\nfunction useEuiI18n<DEFAULTS extends Array<string | ReactElement>>(\n  tokens: string[],\n  defaultValues: DEFAULTS\n): Array<DefaultsRenderType<DEFAULTS>>;\nfunction useEuiI18n(...props: any[]) {\n  const i18nConfig = useContext(I18nContext);\n  const { mapping, mappingFunc, render } = i18nConfig;\n\n  if (typeof props[0] === \"string\") {\n    const [token, defaultValue, values] = props;\n    return lookupToken({\n      token,\n      i18nMapping: mapping,\n      valueDefault: defaultValue,\n      i18nMappingFunc: mappingFunc,\n      values,\n      render,\n    });\n  } else {\n    const [tokens, defaultValues] = props as [string[], string[]];\n    return tokens.map((token, idx) =>\n      lookupToken({\n        token,\n        i18nMapping: mapping,\n        valueDefault: defaultValues[idx],\n        i18nMappingFunc: mappingFunc,\n        render,\n      })\n    );\n  }\n}\n\nexport { EuiI18n, useEuiI18n };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}