{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nconst GROUP_NUMERIC = /^([\\d.]+)(s|ms)/;\nfunction getMilliseconds(value, unit) {\n  // Given the regex match and capture groups, we can assume `unit` to be either 's' or 'ms'\n  const multiplier = unit === 's' ? 1000 : 1;\n  return parseFloat(value) * multiplier;\n}\n// Find CSS `transition-duration` and `transition-delay` intervals\n// and return the value of each computed property in 'ms'\nexport const getTransitionTimings = element => {\n  const computedStyle = window.getComputedStyle(element);\n  const computedDuration = computedStyle.getPropertyValue('transition-duration');\n  const durationMatchArray = computedDuration.match(GROUP_NUMERIC);\n  const durationMatch = durationMatchArray ? getMilliseconds(durationMatchArray[1], durationMatchArray[2]) : 0;\n  const computedDelay = computedStyle.getPropertyValue('transition-delay');\n  const delayMatchArray = computedDelay.match(GROUP_NUMERIC);\n  const delayMatch = delayMatchArray ? getMilliseconds(delayMatchArray[1], delayMatchArray[2]) : 0;\n  return {\n    durationMatch,\n    delayMatch\n  };\n};\nfunction isElementNode(element) {\n  return element.nodeType === document.ELEMENT_NODE;\n}\n// Uses `getTransitionTimings` to find the total transition time for\n// all elements targeted by a MutationObserver callback\nexport const getWaitDuration = records => {\n  return records.reduce((waitDuration, record) => {\n    // only check for CSS transition values for ELEMENT nodes\n    if (isElementNode(record.target)) {\n      const {\n        durationMatch,\n        delayMatch\n      } = getTransitionTimings(record.target);\n      waitDuration = Math.max(waitDuration, durationMatch + delayMatch);\n    }\n    return waitDuration;\n  }, 0);\n};\n\n// Uses `requestAnimationFrame` to perform a given callback after a specified waiting period\nexport const performOnFrame = (waitDuration, toPerform) => {\n  if (waitDuration > 0) {\n    const startTime = Date.now();\n    const endTime = startTime + waitDuration;\n    const onFrame = () => {\n      toPerform();\n      if (endTime > Date.now()) {\n        requestAnimationFrame(onFrame);\n      }\n    };\n    requestAnimationFrame(onFrame);\n  }\n};\n\n// Convenience method for combining the result of 'getWaitDuration' directly with 'performOnFrame'\nexport const getDurationAndPerformOnFrame = (records, toPerform) => {\n  performOnFrame(getWaitDuration(records), toPerform);\n};","map":{"version":3,"names":["GROUP_NUMERIC","getMilliseconds","value","unit","multiplier","parseFloat","getTransitionTimings","element","computedStyle","window","getComputedStyle","computedDuration","getPropertyValue","durationMatchArray","match","durationMatch","computedDelay","delayMatchArray","delayMatch","isElementNode","nodeType","document","ELEMENT_NODE","getWaitDuration","records","reduce","waitDuration","record","target","Math","max","performOnFrame","toPerform","startTime","Date","now","endTime","onFrame","requestAnimationFrame","getDurationAndPerformOnFrame"],"sources":["/Users/nikita/Downloads/super_date_picker/src/services/transition/transition.ts"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nconst GROUP_NUMERIC = /^([\\d.]+)(s|ms)/;\n\nfunction getMilliseconds(value: string, unit: string) {\n  // Given the regex match and capture groups, we can assume `unit` to be either 's' or 'ms'\n  const multiplier = unit === 's' ? 1000 : 1;\n  return parseFloat(value) * multiplier;\n}\n// Find CSS `transition-duration` and `transition-delay` intervals\n// and return the value of each computed property in 'ms'\nexport const getTransitionTimings = (element: Element) => {\n  const computedStyle = window.getComputedStyle(element);\n\n  const computedDuration = computedStyle.getPropertyValue(\n    'transition-duration'\n  );\n  const durationMatchArray = computedDuration.match(GROUP_NUMERIC);\n  const durationMatch = durationMatchArray\n    ? getMilliseconds(durationMatchArray[1], durationMatchArray[2])\n    : 0;\n\n  const computedDelay = computedStyle.getPropertyValue('transition-delay');\n  const delayMatchArray = computedDelay.match(GROUP_NUMERIC);\n  const delayMatch = delayMatchArray\n    ? getMilliseconds(delayMatchArray[1], delayMatchArray[2])\n    : 0;\n\n  return { durationMatch, delayMatch };\n};\n\nfunction isElementNode(element: Node): element is Element {\n  return element.nodeType === document.ELEMENT_NODE;\n}\n// Uses `getTransitionTimings` to find the total transition time for\n// all elements targeted by a MutationObserver callback\nexport const getWaitDuration = (records: MutationRecord[]) => {\n  return records.reduce((waitDuration, record) => {\n    // only check for CSS transition values for ELEMENT nodes\n    if (isElementNode(record.target)) {\n      const { durationMatch, delayMatch } = getTransitionTimings(record.target);\n      waitDuration = Math.max(waitDuration, durationMatch + delayMatch);\n    }\n\n    return waitDuration;\n  }, 0);\n};\n\n// Uses `requestAnimationFrame` to perform a given callback after a specified waiting period\nexport const performOnFrame = (waitDuration: number, toPerform: () => void) => {\n  if (waitDuration > 0) {\n    const startTime = Date.now();\n    const endTime = startTime + waitDuration;\n\n    const onFrame = () => {\n      toPerform();\n\n      if (endTime > Date.now()) {\n        requestAnimationFrame(onFrame);\n      }\n    };\n\n    requestAnimationFrame(onFrame);\n  }\n};\n\n// Convenience method for combining the result of 'getWaitDuration' directly with 'performOnFrame'\nexport const getDurationAndPerformOnFrame = (\n  records: MutationRecord[],\n  toPerform: () => void\n) => {\n  performOnFrame(getWaitDuration(records), toPerform);\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,aAAa,GAAG,iBAAiB;AAEvC,SAASC,eAAe,CAACC,KAAa,EAAEC,IAAY,EAAE;EACpD;EACA,MAAMC,UAAU,GAAGD,IAAI,KAAK,GAAG,GAAG,IAAI,GAAG,CAAC;EAC1C,OAAOE,UAAU,CAACH,KAAK,CAAC,GAAGE,UAAU;AACvC;AACA;AACA;AACA,OAAO,MAAME,oBAAoB,GAAIC,OAAgB,IAAK;EACxD,MAAMC,aAAa,GAAGC,MAAM,CAACC,gBAAgB,CAACH,OAAO,CAAC;EAEtD,MAAMI,gBAAgB,GAAGH,aAAa,CAACI,gBAAgB,CACrD,qBAAqB,CACtB;EACD,MAAMC,kBAAkB,GAAGF,gBAAgB,CAACG,KAAK,CAACd,aAAa,CAAC;EAChE,MAAMe,aAAa,GAAGF,kBAAkB,GACpCZ,eAAe,CAACY,kBAAkB,CAAC,CAAC,CAAC,EAAEA,kBAAkB,CAAC,CAAC,CAAC,CAAC,GAC7D,CAAC;EAEL,MAAMG,aAAa,GAAGR,aAAa,CAACI,gBAAgB,CAAC,kBAAkB,CAAC;EACxE,MAAMK,eAAe,GAAGD,aAAa,CAACF,KAAK,CAACd,aAAa,CAAC;EAC1D,MAAMkB,UAAU,GAAGD,eAAe,GAC9BhB,eAAe,CAACgB,eAAe,CAAC,CAAC,CAAC,EAAEA,eAAe,CAAC,CAAC,CAAC,CAAC,GACvD,CAAC;EAEL,OAAO;IAAEF,aAAa;IAAEG;EAAW,CAAC;AACtC,CAAC;AAED,SAASC,aAAa,CAACZ,OAAa,EAAsB;EACxD,OAAOA,OAAO,CAACa,QAAQ,KAAKC,QAAQ,CAACC,YAAY;AACnD;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAIC,OAAyB,IAAK;EAC5D,OAAOA,OAAO,CAACC,MAAM,CAAC,CAACC,YAAY,EAAEC,MAAM,KAAK;IAC9C;IACA,IAAIR,aAAa,CAACQ,MAAM,CAACC,MAAM,CAAC,EAAE;MAChC,MAAM;QAAEb,aAAa;QAAEG;MAAW,CAAC,GAAGZ,oBAAoB,CAACqB,MAAM,CAACC,MAAM,CAAC;MACzEF,YAAY,GAAGG,IAAI,CAACC,GAAG,CAACJ,YAAY,EAAEX,aAAa,GAAGG,UAAU,CAAC;IACnE;IAEA,OAAOQ,YAAY;EACrB,CAAC,EAAE,CAAC,CAAC;AACP,CAAC;;AAED;AACA,OAAO,MAAMK,cAAc,GAAG,CAACL,YAAoB,EAAEM,SAAqB,KAAK;EAC7E,IAAIN,YAAY,GAAG,CAAC,EAAE;IACpB,MAAMO,SAAS,GAAGC,IAAI,CAACC,GAAG,EAAE;IAC5B,MAAMC,OAAO,GAAGH,SAAS,GAAGP,YAAY;IAExC,MAAMW,OAAO,GAAG,MAAM;MACpBL,SAAS,EAAE;MAEX,IAAII,OAAO,GAAGF,IAAI,CAACC,GAAG,EAAE,EAAE;QACxBG,qBAAqB,CAACD,OAAO,CAAC;MAChC;IACF,CAAC;IAEDC,qBAAqB,CAACD,OAAO,CAAC;EAChC;AACF,CAAC;;AAED;AACA,OAAO,MAAME,4BAA4B,GAAG,CAC1Cf,OAAyB,EACzBQ,SAAqB,KAClB;EACHD,cAAc,CAACR,eAAe,CAACC,OAAO,CAAC,EAAEQ,SAAS,CAAC;AACrD,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}